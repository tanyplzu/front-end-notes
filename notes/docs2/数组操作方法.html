<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数组操作方法 | 朝花夕拾</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="朝花夕拾技术空间">
    <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1, minimum-scale=1">
    <meta name="theme-color" content="#000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.e3cb5c2f.css" as="style"><link rel="preload" href="/assets/js/app.a8b9877c.js" as="script"><link rel="preload" href="/assets/js/38.07455d34.js" as="script"><link rel="preload" href="/assets/js/3.4266fc2a.js" as="script"><link rel="preload" href="/assets/js/181.48f4346f.js" as="script"><link rel="prefetch" href="/assets/js/10.7e3c9793.js"><link rel="prefetch" href="/assets/js/100.8fad8f09.js"><link rel="prefetch" href="/assets/js/101.bf92a0bb.js"><link rel="prefetch" href="/assets/js/102.9c9a1e12.js"><link rel="prefetch" href="/assets/js/103.9d94397d.js"><link rel="prefetch" href="/assets/js/104.45fae0d8.js"><link rel="prefetch" href="/assets/js/105.e469a2a4.js"><link rel="prefetch" href="/assets/js/106.05cd562d.js"><link rel="prefetch" href="/assets/js/107.00054ec4.js"><link rel="prefetch" href="/assets/js/108.b1e26775.js"><link rel="prefetch" href="/assets/js/109.872a4bfe.js"><link rel="prefetch" href="/assets/js/11.760f1f47.js"><link rel="prefetch" href="/assets/js/110.d8932629.js"><link rel="prefetch" href="/assets/js/111.26184b68.js"><link rel="prefetch" href="/assets/js/112.bbb4edc8.js"><link rel="prefetch" href="/assets/js/113.76f21ed1.js"><link rel="prefetch" href="/assets/js/114.72fa2d32.js"><link rel="prefetch" href="/assets/js/115.17682fd3.js"><link rel="prefetch" href="/assets/js/116.5d8d07d5.js"><link rel="prefetch" href="/assets/js/117.d4322307.js"><link rel="prefetch" href="/assets/js/118.77165502.js"><link rel="prefetch" href="/assets/js/119.77ae259d.js"><link rel="prefetch" href="/assets/js/12.ec6bdf8c.js"><link rel="prefetch" href="/assets/js/120.7226c405.js"><link rel="prefetch" href="/assets/js/121.6291170f.js"><link rel="prefetch" href="/assets/js/122.d61e0ac7.js"><link rel="prefetch" href="/assets/js/123.af02bf61.js"><link rel="prefetch" href="/assets/js/124.9d06147b.js"><link rel="prefetch" href="/assets/js/125.a766ef30.js"><link rel="prefetch" href="/assets/js/126.3b624ce8.js"><link rel="prefetch" href="/assets/js/127.dd18836e.js"><link rel="prefetch" href="/assets/js/128.83a90694.js"><link rel="prefetch" href="/assets/js/129.59d0c1bf.js"><link rel="prefetch" href="/assets/js/13.8a12fd4b.js"><link rel="prefetch" href="/assets/js/130.df0cdc8c.js"><link rel="prefetch" href="/assets/js/131.4afc05b9.js"><link rel="prefetch" href="/assets/js/132.d4df2785.js"><link rel="prefetch" href="/assets/js/133.e2659547.js"><link rel="prefetch" href="/assets/js/134.ccbb1caa.js"><link rel="prefetch" href="/assets/js/135.02707ff1.js"><link rel="prefetch" href="/assets/js/136.ca35fe73.js"><link rel="prefetch" href="/assets/js/137.0dbedb82.js"><link rel="prefetch" href="/assets/js/138.da5b4b87.js"><link rel="prefetch" href="/assets/js/139.2d74d642.js"><link rel="prefetch" href="/assets/js/14.464f189c.js"><link rel="prefetch" href="/assets/js/140.f30ec820.js"><link rel="prefetch" href="/assets/js/141.3d82e0cd.js"><link rel="prefetch" href="/assets/js/142.a6e87d3f.js"><link rel="prefetch" href="/assets/js/143.3e450d52.js"><link rel="prefetch" href="/assets/js/144.2da89cdf.js"><link rel="prefetch" href="/assets/js/145.2285aa3e.js"><link rel="prefetch" href="/assets/js/146.f07df7cf.js"><link rel="prefetch" href="/assets/js/147.f945f023.js"><link rel="prefetch" href="/assets/js/148.2a2d1afb.js"><link rel="prefetch" href="/assets/js/149.de6316d0.js"><link rel="prefetch" href="/assets/js/15.258db8d5.js"><link rel="prefetch" href="/assets/js/150.46e4a9b7.js"><link rel="prefetch" href="/assets/js/151.2e9595ad.js"><link rel="prefetch" href="/assets/js/152.413e720a.js"><link rel="prefetch" href="/assets/js/153.f8be589e.js"><link rel="prefetch" href="/assets/js/154.48e07688.js"><link rel="prefetch" href="/assets/js/155.f30f90ae.js"><link rel="prefetch" href="/assets/js/156.25528240.js"><link rel="prefetch" href="/assets/js/157.1076b173.js"><link rel="prefetch" href="/assets/js/158.617cf508.js"><link rel="prefetch" href="/assets/js/159.734fdc71.js"><link rel="prefetch" href="/assets/js/16.6ce4d160.js"><link rel="prefetch" href="/assets/js/160.bd4b9d7b.js"><link rel="prefetch" href="/assets/js/161.5578a756.js"><link rel="prefetch" href="/assets/js/162.0b13b246.js"><link rel="prefetch" href="/assets/js/163.390fd5e8.js"><link rel="prefetch" href="/assets/js/164.b47bbfa3.js"><link rel="prefetch" href="/assets/js/165.868bb1d6.js"><link rel="prefetch" href="/assets/js/166.c576e80e.js"><link rel="prefetch" href="/assets/js/167.a6e137e4.js"><link rel="prefetch" href="/assets/js/168.af5a4d3e.js"><link rel="prefetch" href="/assets/js/169.3adc2a1f.js"><link rel="prefetch" href="/assets/js/17.7d670027.js"><link rel="prefetch" href="/assets/js/170.cc5059d4.js"><link rel="prefetch" href="/assets/js/171.476d0fbf.js"><link rel="prefetch" href="/assets/js/172.65397668.js"><link rel="prefetch" href="/assets/js/173.5cc786c2.js"><link rel="prefetch" href="/assets/js/174.47eff7ee.js"><link rel="prefetch" href="/assets/js/175.513412fa.js"><link rel="prefetch" href="/assets/js/176.d005362d.js"><link rel="prefetch" href="/assets/js/177.aa0d5dcf.js"><link rel="prefetch" href="/assets/js/178.d350acfe.js"><link rel="prefetch" href="/assets/js/179.dc0f79cf.js"><link rel="prefetch" href="/assets/js/18.0c87bb52.js"><link rel="prefetch" href="/assets/js/180.6e0d9412.js"><link rel="prefetch" href="/assets/js/182.d0a654af.js"><link rel="prefetch" href="/assets/js/183.eb415093.js"><link rel="prefetch" href="/assets/js/184.80efbf3c.js"><link rel="prefetch" href="/assets/js/185.2d8065a8.js"><link rel="prefetch" href="/assets/js/186.729a4b39.js"><link rel="prefetch" href="/assets/js/187.43b47627.js"><link rel="prefetch" href="/assets/js/188.d08050ec.js"><link rel="prefetch" href="/assets/js/189.a907c975.js"><link rel="prefetch" href="/assets/js/19.61503aa6.js"><link rel="prefetch" href="/assets/js/190.ff958065.js"><link rel="prefetch" href="/assets/js/191.2b78c49f.js"><link rel="prefetch" href="/assets/js/192.0b2ef12d.js"><link rel="prefetch" href="/assets/js/193.0a064552.js"><link rel="prefetch" href="/assets/js/194.76e8c0c1.js"><link rel="prefetch" href="/assets/js/195.3c29cb28.js"><link rel="prefetch" href="/assets/js/196.dabf4562.js"><link rel="prefetch" href="/assets/js/197.93159cb3.js"><link rel="prefetch" href="/assets/js/198.646e558e.js"><link rel="prefetch" href="/assets/js/199.fa132c11.js"><link rel="prefetch" href="/assets/js/20.499c66b8.js"><link rel="prefetch" href="/assets/js/200.45bf45b3.js"><link rel="prefetch" href="/assets/js/201.c13c1966.js"><link rel="prefetch" href="/assets/js/21.80086b8f.js"><link rel="prefetch" href="/assets/js/22.c2ca466b.js"><link rel="prefetch" href="/assets/js/23.f788a28b.js"><link rel="prefetch" href="/assets/js/24.fe2c53dc.js"><link rel="prefetch" href="/assets/js/25.601f974f.js"><link rel="prefetch" href="/assets/js/26.0968cc26.js"><link rel="prefetch" href="/assets/js/27.35c8c17c.js"><link rel="prefetch" href="/assets/js/28.cc146e5e.js"><link rel="prefetch" href="/assets/js/29.e9972120.js"><link rel="prefetch" href="/assets/js/30.6dbe8778.js"><link rel="prefetch" href="/assets/js/31.ebaaaa99.js"><link rel="prefetch" href="/assets/js/32.6de41086.js"><link rel="prefetch" href="/assets/js/33.a8ac0ead.js"><link rel="prefetch" href="/assets/js/34.354aac22.js"><link rel="prefetch" href="/assets/js/35.cc0859c0.js"><link rel="prefetch" href="/assets/js/36.31e91915.js"><link rel="prefetch" href="/assets/js/37.753c49e7.js"><link rel="prefetch" href="/assets/js/39.37fd1928.js"><link rel="prefetch" href="/assets/js/4.59d94f07.js"><link rel="prefetch" href="/assets/js/40.32d84875.js"><link rel="prefetch" href="/assets/js/41.584f41d4.js"><link rel="prefetch" href="/assets/js/42.f078dc5c.js"><link rel="prefetch" href="/assets/js/43.e7b83320.js"><link rel="prefetch" href="/assets/js/44.7cfb5300.js"><link rel="prefetch" href="/assets/js/45.a68d458c.js"><link rel="prefetch" href="/assets/js/46.5a5a2d30.js"><link rel="prefetch" href="/assets/js/47.1282d427.js"><link rel="prefetch" href="/assets/js/48.3a09108e.js"><link rel="prefetch" href="/assets/js/49.5bcc43da.js"><link rel="prefetch" href="/assets/js/5.72011a12.js"><link rel="prefetch" href="/assets/js/50.ab4dfe10.js"><link rel="prefetch" href="/assets/js/51.3bb850d0.js"><link rel="prefetch" href="/assets/js/52.55ab3af5.js"><link rel="prefetch" href="/assets/js/53.3ff3d1e6.js"><link rel="prefetch" href="/assets/js/54.128ce87b.js"><link rel="prefetch" href="/assets/js/55.e631412b.js"><link rel="prefetch" href="/assets/js/56.701afab8.js"><link rel="prefetch" href="/assets/js/57.57c3070c.js"><link rel="prefetch" href="/assets/js/58.4e47775b.js"><link rel="prefetch" href="/assets/js/59.80978f39.js"><link rel="prefetch" href="/assets/js/6.63f31918.js"><link rel="prefetch" href="/assets/js/60.375f995f.js"><link rel="prefetch" href="/assets/js/61.19b51909.js"><link rel="prefetch" href="/assets/js/62.3f00cb37.js"><link rel="prefetch" href="/assets/js/63.09e22fc4.js"><link rel="prefetch" href="/assets/js/64.c48daeef.js"><link rel="prefetch" href="/assets/js/65.21e432e0.js"><link rel="prefetch" href="/assets/js/66.841a07b6.js"><link rel="prefetch" href="/assets/js/67.f9524d7b.js"><link rel="prefetch" href="/assets/js/68.84d5df33.js"><link rel="prefetch" href="/assets/js/69.176adb7f.js"><link rel="prefetch" href="/assets/js/7.76b96dc4.js"><link rel="prefetch" href="/assets/js/70.5e41fe9f.js"><link rel="prefetch" href="/assets/js/71.3d4ab6d7.js"><link rel="prefetch" href="/assets/js/72.dee742b1.js"><link rel="prefetch" href="/assets/js/73.31646f74.js"><link rel="prefetch" href="/assets/js/74.f14be1ec.js"><link rel="prefetch" href="/assets/js/75.85e7a243.js"><link rel="prefetch" href="/assets/js/76.df148af5.js"><link rel="prefetch" href="/assets/js/77.c5eafd52.js"><link rel="prefetch" href="/assets/js/78.fc266a91.js"><link rel="prefetch" href="/assets/js/79.7a3b35e5.js"><link rel="prefetch" href="/assets/js/8.e43d1c4a.js"><link rel="prefetch" href="/assets/js/80.c420cc0b.js"><link rel="prefetch" href="/assets/js/81.c958064d.js"><link rel="prefetch" href="/assets/js/82.561531ef.js"><link rel="prefetch" href="/assets/js/83.7a5e2c57.js"><link rel="prefetch" href="/assets/js/84.bcf5d8a8.js"><link rel="prefetch" href="/assets/js/85.7d4c4727.js"><link rel="prefetch" href="/assets/js/86.0fe1af77.js"><link rel="prefetch" href="/assets/js/87.137e849f.js"><link rel="prefetch" href="/assets/js/88.754d6700.js"><link rel="prefetch" href="/assets/js/89.b9be2977.js"><link rel="prefetch" href="/assets/js/9.2fd4544c.js"><link rel="prefetch" href="/assets/js/90.3fd6f93a.js"><link rel="prefetch" href="/assets/js/91.16cd663e.js"><link rel="prefetch" href="/assets/js/92.dde8aa38.js"><link rel="prefetch" href="/assets/js/93.78b6c2d8.js"><link rel="prefetch" href="/assets/js/94.cdce293d.js"><link rel="prefetch" href="/assets/js/95.90614099.js"><link rel="prefetch" href="/assets/js/96.32c523b9.js"><link rel="prefetch" href="/assets/js/97.116c61e7.js"><link rel="prefetch" href="/assets/js/98.0c3beeb5.js"><link rel="prefetch" href="/assets/js/99.a81e2940.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.97f4fe72.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e3cb5c2f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">朝花夕拾</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Introduction.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/FrontEnd/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://vue3.tanyp.xyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue3
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/React/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link">
  Vue2
</a></li><li class="dropdown-item"><!----> <a href="/AngularJS/" class="nav-link">
  AngularJS
</a></li></ul></div></div><div class="nav-item"><a href="/JsFrame/" class="nav-link">
  技术方案
</a></div><div class="nav-item"><a href="/FrontEndTool/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/NodeJS/" class="nav-link">
  NodeJS
</a></div><div class="nav-item"><a href="/TS/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/Java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">
  Notes
</a></div><div class="nav-item"><a href="/Reading/" class="nav-link">
  Reading
</a></div><div class="nav-item"><a href="/DSA/" class="nav-link">
  数据结构与算法
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Introduction.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/FrontEnd/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://vue3.tanyp.xyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue3
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/React/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link">
  Vue2
</a></li><li class="dropdown-item"><!----> <a href="/AngularJS/" class="nav-link">
  AngularJS
</a></li></ul></div></div><div class="nav-item"><a href="/JsFrame/" class="nav-link">
  技术方案
</a></div><div class="nav-item"><a href="/FrontEndTool/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/NodeJS/" class="nav-link">
  NodeJS
</a></div><div class="nav-item"><a href="/TS/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/Java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">
  Notes
</a></div><div class="nav-item"><a href="/Reading/" class="nav-link">
  Reading
</a></div><div class="nav-item"><a href="/DSA/" class="nav-link">
  数据结构与算法
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>基础语法：</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/docs1/对象静态方法总结分享.html" class="sidebar-link">Object 静态方法总结</a></li><li><a href="/notes/docs1/regexp1.html" class="sidebar-link">JavaScript 正则表达式</a></li><li><a href="/notes/docs1/regexp2.html" class="sidebar-link">正则表达式中的括号</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>文档(一)：</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/docs1/性能优化.html" class="sidebar-link">前端性能优化</a></li><li><a href="/notes/docs1/router.html" class="sidebar-link">前端路由</a></li><li><a href="/notes/docs1/Vue虚拟DOM和渲染流程.html" class="sidebar-link">Vue 虚拟 DOM 及渲染流程</a></li><li><a href="/notes/docs1/编译型语言和解释型语言.html" class="sidebar-link">编译型语言和解释型语言</a></li><li><a href="/notes/docs1/手机端开发问题汇总.html" class="sidebar-link">手机端开发问题汇总</a></li><li><a href="/notes/docs1/前端面试.html" class="sidebar-link">前端常考面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>文档(二)：</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/docs2/数字.html" class="sidebar-link">前端数字</a></li><li><a href="/notes/docs2/字符串方法.html" class="sidebar-link">String</a></li><li><a href="/notes/docs2/math.html" class="sidebar-link">math</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>文档(三)：</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/docs4/密码学.html" class="sidebar-link">卓克密码学 30 讲</a></li><li><a href="/notes/docs4/vuepress.html" class="sidebar-link">vuepress 配置</a></li><li><a href="/notes/docs4/vsCode.html" class="sidebar-link">VS Code 快捷键</a></li><li><a href="/notes/docs4/Java英语.html" class="sidebar-link">Java 英语</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数组操作方法"><a href="#数组操作方法" class="header-anchor">#</a> 数组操作方法</h1> <blockquote><p>同事的资料</p></blockquote> <h3 id="构造数组"><a href="#构造数组" class="header-anchor">#</a> 构造数组</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 字面量方式:</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//最常用的，简洁方便</span>
a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// [empty × 3]</span>

<span class="token comment">// 使用构造器:</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[]</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[undefined × 3]</span>
<span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[1,2,3]</span>

<span class="token comment">// 数组长度最大为Math.pow(2,32)-1 ,即 4294967294 位</span>

<span class="token comment">// 两种方式性能PK？</span>
<span class="token keyword">var</span> startTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> num <span class="token operator">&lt;</span> <span class="token number">2000000</span><span class="token punctuation">;</span> num<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> endTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new Array()输出耗时:'</span><span class="token punctuation">,</span> endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//----------------------</span>
<span class="token keyword">var</span> startTime2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> num2 <span class="token operator">&lt;</span> <span class="token number">2000000</span><span class="token punctuation">;</span> num2<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a2<span class="token punctuation">[</span>num2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> endTime2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[]输出耗时:'</span><span class="token punctuation">,</span> endTime2 <span class="token operator">-</span> startTime2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//数十万数百万级</span>
</code></pre></div><h3 id="es6-中新增的构造方法"><a href="#es6-中新增的构造方法" class="header-anchor">#</a> ES6 中新增的构造方法</h3> <h4 id="array-of"><a href="#array-of" class="header-anchor">#</a> Array.of</h4> <p>Array.of 用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其它。它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>Array<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [3]</span>
<span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [undefined × 3]</span>

<span class="token comment">// 参数为多个，或单个参数不是数字时，Array.of 与 Array构造器等同:</span>
Array<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2]</span>
<span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2]</span>
Array<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;8&quot;]</span>
<span class="token function">Array</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;8&quot;]</span>

<span class="token comment">// 即使其他版本浏览器不支持也不必担心，由于Array.of与Array构造器的这种高度相似性，实现一个polyfill十分简单。如下：</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span>of<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Array<span class="token punctuation">.</span><span class="token function-variable function">of</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//return [].slice.call(arguments);</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="array-from"><a href="#array-from" class="header-anchor">#</a> Array.from</h4> <p>语法：Array.from(arrayLike, processingFn, thisArg)</p> <div class="language- extra-class"><pre class="language-text"><code>Array.from的设计初衷是快速便捷的基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象创建一个新的数组实例
//简单来说，只要这个对象有迭代器，Array.from就能把它变成一个数组（当然，是返回新的数组，不改变原对象）。

从语法上看，Array.from拥有3个形参，第一个为类似数组的对象，必选。第二个为加工函数，新生成的数组会经过该函数的加工再返回。第三个为this作用域，表示加工函数执行时this的值。后两个参数都是可选的。

var obj = {0: 'a', 1: 'b', 2:'c', length: 3};
Array.from(obj, function(value, index){
  console.log(value, index, this, arguments.length);
  return value.repeat(2); //必须指定返回值，否则返回undefined
  //加工函数变成箭头函数会怎么样？
}, obj);//[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]

以上可简化为：
Array.from(obj, (value) =&gt; value.repeat(2));

生成一个从0到指定数字的新数组，Array.from就可以轻易的做到：
Array.from({length: 10}, (v, i) =&gt; i); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre></div><h4 id="array-isarray"><a href="#array-isarray" class="header-anchor">#</a> Array.isArray</h4> <p>用来判断一个变量是否数组类型</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 我们至少有如下5种方式去判断一个值是否数组：</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 1.基于instanceof</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span>
<span class="token comment">// 2.基于constructor</span>
a<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">;</span>
<span class="token comment">// 3.基于Object.prototype.isPrototypeOf</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 4.基于getPrototypeOf</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token comment">// 5.基于Object.prototype.toString</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">;</span>

<span class="token comment">// 但由于代码的运行环境十分复杂，加上JS的弱类型机制，导致可以随时手动指定了某个对象的__proto__：</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">__proto__</span><span class="token operator">:</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 分别在控制台试运行以下代码</span>
<span class="token comment">// 1.基于instanceof</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// 2.基于constructor</span>
a<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// 3.基于Object.prototype.isPrototypeOf</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// 4.基于getPrototypeOf</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">//流氓继承方式，使上面的判断瞬间GG了</span>

<span class="token comment">// 以上，除了Object.prototype.toString外，其它方法都不能正确判断变量的类型。</span>

<span class="token comment">// 使用Array.isArray则非常简单</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <p>数组原型提供的方法非常之多，主要分为三种，一种是会改变自身值的，一种是不会改变自身值的，另外一种是遍历方法。</p> <p>改变自身值的方法 (11 个），分别为<strong>unshift、shift、push、pop、splice、reverse、sort</strong>，以及两个 ES6 新增的方法<strong>flat、flatMap、copyWithin</strong> 和 <strong>fill</strong>。 <strong>unshift</strong> 语法：arr.unshift(element1, …, elementN)</p> <div class="language- extra-class"><pre class="language-text"><code>unshift() 方法用于在数组开始处插入一些元素(就像是栈底插入)，并返回数组新的长度。

let array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
let length = array.unshift(&quot;yellow&quot;);
console.log(array); // [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]
console.log(length); // 4
</code></pre></div><p><strong>shift</strong> 语法：arr.shift()</p> <div class="language- extra-class"><pre class="language-text"><code>shift()方法删除数组的第一个元素，并返回这个元素。

let array = [1,2,3,4,5];
let item = array.shift();
console.log(array); // [2,3,4,5]
console.log(item); // 1
</code></pre></div><h6 id="push"><a href="#push" class="header-anchor">#</a> push</h6> <p>语法：arr.push(element1, …, elementN)</p> <div class="language- extra-class"><pre class="language-text"><code>push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度。

let array = [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;];
let i = array.push(&quot;Table tennis&quot;);
console.log(array); // [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;]
console.log(i); // 4
</code></pre></div><h6 id="pop"><a href="#pop" class="header-anchor">#</a> pop</h6> <p>语法：arr.pop()</p> <div class="language- extra-class"><pre class="language-text"><code>pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。

let array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];
let item = array.pop();
console.log(array); // [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]
console.log(item); // mouse
</code></pre></div><h6 id="splice"><a href="#splice" class="header-anchor">#</a> splice</h6> <p>语法：arr.splice(start,deleteCount,[item1, item2, …])</p> <div class="language- extra-class"><pre class="language-text"><code>splice()方法用新元素替换旧元素的方式来修改数组。

start 指定从哪一位开始修改内容。如果超过了数组长度，则从数组末尾开始添加内容；如果是负值，则其指定的索引位置等同于 length+start (length为数组的长度)，表示从数组末尾开始的第 -start 位。
deleteCount 指定要删除的元素个数，若等于0，则不删除。这种情况下，至少应该添加一位新元素，若大于start之后的元素总和，则start及之后的元素都将被删除。
itemN 指定新增的元素，如果缺省，则该方法只删除数组元素。
返回值 由原数组中被删除元素组成的数组，如果没有删除，则返回一个空数组。

let array = [&quot;apple&quot;,&quot;boy&quot;];
let splices = array.splice(-3,1,&quot;cat&quot;);
console.log(array); // [&quot;cat&quot;, &quot;boy&quot;]
console.log(splices); // [&quot;apple&quot;], 可见即使-start超出数组长度,数组默认从首位开始删除
------
let array = [&quot;apple&quot;,&quot;boy&quot;];
let splices = array.splice(3,3,&quot;cat&quot;);
console.log(array); // [&quot;cat&quot;]
console.log(splices); // [&quot;apple&quot;, &quot;boy&quot;]
可见当start超出数组长度，数组没变化，默认从末尾该添加啥添加啥
</code></pre></div><h6 id="reverse"><a href="#reverse" class="header-anchor">#</a> reverse</h6> <p>语法：arr.reverse()</p> <div class="language- extra-class"><pre class="language-text"><code>reverse()方法颠倒数组中元素的位置，第一个会成为最后一个，最后一个会成为第一个，该方法返回对数组的引用。

let array = [1,2,3,4,5];
let array2 = array.reverse();
console.log(array); // [5,4,3,2,1]
console.log(array2===array); // true
</code></pre></div><h6 id="sort"><a href="#sort" class="header-anchor">#</a> sort</h6> <p>语法：arr.sort([comparefn])</p> <div class="language- extra-class"><pre class="language-text"><code>sort()方法对数组元素进行排序，并返回这个数组。

comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序，例如”Boy”将排到”apple”之前。当对数字排序的时候，25将会排到8之前，因为转换为字符串后，”25”将比”8”靠前。例如：

let array = [&quot;Boy&quot;,&quot;apple&quot;,&quot;Cat&quot;,&quot;dog&quot;];
let array2 = array.sort();
console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]
console.log(array2 == array); // true
let array3 = array.sort((a, b) =&gt; a.localeCompare(b));
console.log(array3)//[&quot;apple&quot;, &quot;Boy&quot;, &quot;Cat&quot;, &quot;dog&quot;]

let array = [10, 1, 3, 20];
let array1 = array.sort();
console.log(array1); // [1, 10, 20, 3]
let array2 = array.sort((a, b) =&gt; a-b);
console.log(array2)//[1, 3, 10, 20]

实际上，ECMAscript规范中并未规定具体的sort算法，这就势必导致各个浏览器不尽相同的sort算法，请看sort方法在Chrome浏览器下表现：

let array = [{ n: &quot;a&quot;, v: 1 }, { n: &quot;b&quot;, v: 1 }, { n: &quot;c&quot;, v: 1 }, { n: &quot;d&quot;, v: 1 }, { n: &quot;e&quot;, v: 1 }, { n: &quot;f&quot;, v: 1 }, { n: &quot;g&quot;, v: 1 }, { n: &quot;h&quot;, v: 1 }, { n: &quot;i&quot;, v: 1 }, { n: &quot;j&quot;, v: 1 }, { n: &quot;k&quot;, v: 1 }, ];
array.sort((a, b) =&gt; return a.v - b.v);
for (let i = 0,len = array.length; i &lt; len; i++) {
    console.log(array[i].n);
}

由于v值相等，array数组排序前后应该不变，然而Chrome却表现异常，而其他浏览器(如IE 或 Firefox) 表现正常。
这是因为v8引擎为了高效排序(采用了不稳定排序)。即数组长度超过10条时，会调用另一种排序方法(快速排序)；而10条及以下采用的是插入排序，此时结果将是稳定的。

解决办法：
// 由于快速排序会打乱值相同的元素的默认排序，因此我们需要先标记元素的默认位置
array.forEach((v, k) =&gt;v.__index = k);
// 由于__index标记了初始顺序，这样的返回才保证了值相同元素的顺序不变，进而使得排序稳定
array.sort((a, b) =&gt; return a.v - b.v || a.__index - b.__index);

值得注意的是:
各浏览器的针对sort方法内部算法实现不尽相同，排序函数尽量只返回-1、0、1三种不同的值，不要尝试返回true或false等其它数值，因为可能导致不可靠的排序结果。

let array = [7, 6, 5, 4, 3, 2, 1, 0, 10, 9, 8];
let comparefn = (x, y) =&gt; x &gt; y;
array.sort(comparefn);
</code></pre></div><h6 id="flat"><a href="#flat" class="header-anchor">#</a> flat</h6> <p>语法：arr.flat(depth)</p> <div class="language- extra-class"><pre class="language-text"><code>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity 作为深度，展开任意深度的嵌套数组
arr2.flat(Infinity);
// [1, 2, 3, 4, 5, 6]

var arr4 = [1, 2, , 4, 5];
arr4.flat(); //flat() 方法会移除数组中的空项:
// [1, 2, 4, 5]
</code></pre></div><h6 id="flatmap"><a href="#flatmap" class="header-anchor">#</a> flatMap</h6> <p>语法：arr.flat(fn,thisArg)</p> <div class="language- extra-class"><pre class="language-text"><code>flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。

var arr1 = [1, 2, 3, 4];

arr1.flatMap(x =&gt; [x * 2]);
// [2, 4, 6, 8]

// 只会将 flatMap 中的函数返回的数组 “压平” 一层
arr1.flatMap(x =&gt; [[x * 2]]);
// [[2], [4], [6], [8]]
</code></pre></div><h6 id="copywithin-es6"><a href="#copywithin-es6" class="header-anchor">#</a> copyWithin(ES6)</h6> <p>语法：arr.copyWithin(target, start, end)</p> <div class="language- extra-class"><pre class="language-text"><code>copyWithin() 方法基于ECMAScript 2015（ES6）规范，用于数组内元素之间的替换，即替换元素和被替换元素均是数组内的元素。
其中，taget 指定被替换元素的索引，start 指定替换元素起始的索引，end 可选，指的是替换元素结束位置的索引。
如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。

let array = [1,2,3,4,5];
let array2 = array.copyWithin(0,3);
console.log(array===array2,array2); // true [4, 5, 3, 4, 5]

let array = [1,2,3,4,5];
console.log(array.copyWithin(0,3,4)); // [4, 2, 3, 4, 5]

let array = [1,2,3,4,5];
console.log(array.copyWithin(0,-2,-1)); // [4, 2, 3, 4, 5]
</code></pre></div><h6 id="fill-es6"><a href="#fill-es6" class="header-anchor">#</a> fill(ES6)</h6> <p>语法：arr.fill(value, start, end)</p> <div class="language- extra-class"><pre class="language-text"><code>fill() 方法基于ECMAScript 2015（ES6）规范，它同样用于数组元素替换，但与copyWithin略有不同，它主要用于将数组指定区间内的元素替换为某个值。
其中，value 指定被替换的值，start 指定替换元素起始的索引，end 可选，指的是替换元素结束位置的索引。
如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。

let array = [1,2,3,4,5];
let array2 = array.fill(10,0,3);
console.log(array===array2,array2); // true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10
</code></pre></div><p>不会改变自身的方法 (9 个），分别为<strong>concat、join、slice、toString、toLocateString、indexOf、lastIndexOf、<strong>未标准的</strong>toSource</strong>以及 ES7 新增的方法<strong>includes</strong>。</p> <h6 id="concat"><a href="#concat" class="header-anchor">#</a> concat</h6> <p>语法：arr.concat(value1, value2, …, valueN)</p> <div class="language- extra-class"><pre class="language-text"><code>concat() 方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回。

let array = [1, 2, 3];
let array2 = array.concat(4,[5,6],[7,8,9]);
console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(array); // [1, 2, 3], 可见原数组并未被修改

若concat方法中不传入参数，那么将基于原数组浅复制生成一个一模一样的新数组（指向新的地址空间）。

let array = [{a: 1}];
let array3 = array.concat();
console.log(array3); // [{a: 1}]
console.log(array3 === array); // false
console.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用

</code></pre></div><h6 id="join"><a href="#join" class="header-anchor">#</a> join</h6> <p>语法：arr.join([separator = ‘,’]) separator 可选，缺省默认为逗号。</p> <div class="language- extra-class"><pre class="language-text"><code>join() 方法将数组中的所有元素连接成一个字符串。

let array = ['We', 'are', 'Chinese'];
console.log(array.join()); // &quot;We,are,Chinese&quot;
console.log(array.join('+')); // &quot;We+are+Chinese&quot;
console.log(array.join('')); // &quot;WeareChinese&quot;
</code></pre></div><h6 id="slice"><a href="#slice" class="header-anchor">#</a> slice</h6> <p>语法：arr.slice(start, end)</p> <div class="language- extra-class"><pre class="language-text"><code>slice() 方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。
参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。

如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。

slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。

let array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];
console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]
console.log(array.slice(2,3)); // [&quot;three&quot;]

let array = [{color:&quot;yellow&quot;}, 2, 3];
let array2 = array.slice(0,1);
console.log(array2); // [{color:&quot;yellow&quot;}]
array[0][&quot;color&quot;] = &quot;blue&quot;;
console.log(array2); // [{color:&quot;bule&quot;}]

</code></pre></div><h6 id="tostring"><a href="#tostring" class="header-anchor">#</a> toString</h6> <p>语法：arr.toString()</p> <div class="language- extra-class"><pre class="language-text"><code>toString() 方法返回数组的字符串形式，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。

let array = ['Jan', 'Feb', 'Mar', 'Apr'];
let str = array.toString();
console.log(str); // Jan,Feb,Mar,Apr
</code></pre></div><h6 id="tolocalestring"><a href="#tolocalestring" class="header-anchor">#</a> toLocaleString</h6> <p>语法：arr.toLocaleString()</p> <div class="language- extra-class"><pre class="language-text"><code>toLocaleString() 类似toString()的变型，该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。

let array= [{name:'zz'}, 123, &quot;abc&quot;, new Date()];
let str = array.toLocaleString();
console.log(str); // [object Object],123,abc,2019/3/28 下午12:16:23

toString()和toLocaleString()两点区别：

1.当数字是四位数及以上时
    let a=1234.5678
    a.toString()//&quot;1234.5678&quot;
    a.toLocaleString()//&quot;1,234.568&quot;
2.当目标是标准时间格式时
    let sd=new Date()//Thu Mar 07 2019 12:11:55 GMT+0800 (中国标准时间)
    sd.toLocaleString()//&quot;2019/3/7 下午12:21:55&quot;
    sd.toString()//Thu Mar 07 2019 12:11:55 GMT+0800
</code></pre></div><h6 id="indexof"><a href="#indexof" class="header-anchor">#</a> indexOf</h6> <p>语法：arr.indexOf(element, fromIndex=0)</p> <div class="language- extra-class"><pre class="language-text"><code>indexOf() 方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1。

element 为需要查找的元素,fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + fromIndex项开始往数组末尾查找，如果length + fromIndex&lt;0 则整个数组都会被查找。

let array = ['abc', 'def', 'ghi','123'];
console.log(array.indexOf('def')); // 1
console.log(array.indexOf('def',-1)); // -1 此时表示从最后一个元素往后查找,因此查找失败返回-1
console.log(array.indexOf('def',-4)); // 1 由于4大于数组长度,此时将查找整个数组,因此返回1
console.log(array.indexOf(123)); // -1, 由于是严格匹配,因此并不会匹配到字符串'123'
</code></pre></div><h6 id="lastindexof"><a href="#lastindexof" class="header-anchor">#</a> lastIndexOf</h6> <p>语法：arr.lastIndexOf(element, fromIndex=length-1)</p> <div class="language- extra-class"><pre class="language-text"><code>lastIndexOf() 方法用于查找元素在数组中最后一次出现时的索引，如果没有，则返回-1。并且它是indexOf的逆向查找，即从数组最后一个往前查找。

element 为需要查找的元素,fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + fromIndex项开始往数组末尾查找，如果length + fromIndex&lt;0 则整个数组都会被查找。

同 indexOf 一样，lastIndexOf 也是严格匹配数组元素。
</code></pre></div><h6 id="includes-es7"><a href="#includes-es7" class="header-anchor">#</a> includes(ES7)</h6> <p>语法：arr.includes(element, fromIndex=0)</p> <div class="language- extra-class"><pre class="language-text"><code>includes() 方法基于ECMAScript 2016（ES7）规范，它用来判断当前数组是否包含某个指定的值，如果是，则返回 true，否则返回 false。

element 为需要查找的元素,fromIndex 表示从该索引位置开始查找 element，缺省为0，它是正向查找，即从索引处往数组末尾查找。

let array = [0, 1, 2];
console.log(array.includes(0)); // true
console.log(array.includes(1)); // true
console.log(array.includes(2,-4)); // true

你可能会问，既然有了indexOf方法，为什么又造一个includes方法，arr.indexOf(x)&gt;-1不就等于arr.includes(x)？看起来是的，几乎所有的时候它们都等同，唯一的区别就是includes能够发现NaN，而indexOf不能。

let array = [NaN];
console.log(array.includes(NaN)); // true
console.log(arra.indexOf(NaN)&gt;-1); // false
</code></pre></div><h6 id="tosource-非标准"><a href="#tosource-非标准" class="header-anchor">#</a> toSource（非标准）</h6> <p>语法：arr.toSource()</p> <div class="language- extra-class"><pre class="language-text"><code>toSource() 方法是非标准的，该方法返回数组的源代码

let array = ['a', 'b', 'c'];
console.log(array.toSource()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。

function employee(name,job,born)
{
this.name=name;
this.job=job;
this.born=born;
}

var bill=new employee(&quot;Bill Gates&quot;,&quot;Engineer&quot;,1985);

document.write(bill.toSource());
//({name:&quot;Bill Gates&quot;, job:&quot;Engineer&quot;, born:1985})
</code></pre></div><p>遍历方法 (12 个）基于 ES6，不会改变自身的方法一共有 12 个，分别为<strong>forEach、every、some、filter、map、reduce、reduceRight</strong> 以及 ES6 新增的方法<strong>entries、find、findIndex、keys、values</strong>。</p> <h6 id="foreach"><a href="#foreach" class="header-anchor">#</a> forEach</h6> <p>语法：arr.forEach(fn, thisArg)</p> <div class="language- extra-class"><pre class="language-text"><code>forEach() 方法指定数组的每项元素都执行一次传入的函数，返回值为undefined。

fn 表示在数组每一项上执行的函数，接受三个参数：
value 当前正在被处理的元素的值
index 当前元素的数组索引
array 数组本身
thisArg 可选，用来当做fn函数内的this对象。

forEach 将为数组中每一项执行一次 fn 函数，那些已删除，新增或者从未赋值的项将被跳过（但不包括值为 undefined 的项）。

let array = [1, 3, 5];
let obj = {name:'cc'};
let sReturn = array.forEach(function(value, index, array){
  array[index] = value * value;
  console.log(this.name); // cc被打印了三次
},obj);
console.log(array); // [1, 9, 25], 可见原数组改变了
console.log(sReturn); // undefined, 可见返回值为undefined

*forEach无法直接退出循环，只能使用return 来达到for循环中continue的效果
*它总是返回 undefined值,即使你return了一个值。

1. 对于空数组是不会执行回调函数的
2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数
3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。
4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。
eg:
let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)
let obj = { name: 'obj的名字' };
let result = a.forEach(function (value, index, array) {
    a[3] = '改变元素';
    a.push('添加到尾端，不会被遍历')
    console.log(value, 'forEach传递的第一个参数'); // 分别打印 1 ,2 ,改变元素
    console.log(this.name); // 'obj的名字' 打印三次 this绑定在obj对象上
    // break; // break会报错
    return value; // return只能结束本次回调 会执行下次回调
    console.log('不会执行，因为return 会执行下一次循环回调')
}, obj);
console.log(result); // 即使return了一个值,也还是返回undefined
</code></pre></div><h6 id="every"><a href="#every" class="header-anchor">#</a> every</h6> <p>语法：arr.every(fn, thisArg)</p> <div class="language- extra-class"><pre class="language-text"><code>every()方法检测数组所有元素是否都符合判断条件（参数同上)

方法返回值规则:
1 ，如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测
2. 如果所有元素都满足条件，则返回 true

eg:
function isBigEnough(element, index, array) {
  return element &gt;= 10; // 判断数组中的所有元素是否都大于10
}
[12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); // false
[12, 54, 18, 130, 44].every(x =&gt; x &gt;= 10); // true
</code></pre></div><h6 id="some"><a href="#some" class="header-anchor">#</a> some</h6> <p>语法：arr.some(fn, thisArg)</p> <div class="language- extra-class"><pre class="language-text"><code>some()数组中的是否有满足判断条件的元素（参数同上)

方法返回值规则:
1 ，如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测
2. 如果没有满足条件的元素，则返回false

eg:
function isBigEnough(element, index, array) {
   return (element &gt;= 10); //数组中是否有一个元素大于 10
}
let result = [2, 5, 8, 1, 4].some(isBigEnough); // false
let result = [12, 5, 8, 1, 4].some(isBigEnough); // true
</code></pre></div><h6 id="filter"><a href="#filter" class="header-anchor">#</a> filter</h6> <p>语法：arr.filter(fn, thisArg)</p> <div class="language- extra-class"><pre class="language-text"><code>filter()过滤原始数组，返回通过所提供函数实现的所有元素组成的新数组（参数同上)

eg:
let a = [32, 33, 16, 40];
let result = a.filter(function (value, index, array) {
  return value &gt;= 18; // 返回a数组中所有大于18的元素
});
console.log(result,a);// [32,33,40] [32,33,16,40]
</code></pre></div><h6 id="map"><a href="#map" class="header-anchor">#</a> map</h6> <p>语法：arr.map(fn, thisArg)</p> <div class="language- extra-class"><pre class="language-text"><code>map()对数组中的每个元素进行处理，返回新的数组（参数同上)

eg:
let a = ['1','2','3','4'];
let result = a.map(function (value, index, array) {
  return value + 0
});
console.log(result); /[&quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;]
</code></pre></div><h6 id="reduce"><a href="#reduce" class="header-anchor">#</a> reduce</h6> <p>语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</p> <div class="language- extra-class"><pre class="language-text"><code>reduce()为数组提供累加器，合并为一个值

1. 如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值
2. 如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError
3. 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回

eg:
// 数组求和
let sum = [0, 1, 2, 3].reduce(function (a, b) {
  return a + b;
}, 0);
// 6
------
// 将二维数组转化为一维 将数组元素展开//见flat()
let flattened = [[0, 1], [2, 3], [4, 5]].reduce((a, b) =&gt; a.concat(b),[]);
 // [0, 1, 2, 3, 4, 5]
</code></pre></div><h6 id="reduceright"><a href="#reduceright" class="header-anchor">#</a> reduceRight</h6> <p>语法：array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)</p> <div class="language- extra-class"><pre class="language-text"><code>这个方法除了与reduce执行方向相反外，其他完全与其一致
</code></pre></div><h6 id="es6-keys-values-entries-遍历键名、遍历键值、遍历键名-键值"><a href="#es6-keys-values-entries-遍历键名、遍历键值、遍历键名-键值" class="header-anchor">#</a> ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名 + 键值</h6> <div class="language- extra-class"><pre class="language-text"><code>三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值

eg:
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;

在for..of中如果遍历中途要退出，可以使用break退出循环。

如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历:

let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
</code></pre></div><h6 id="es6-find-findindex-根据条件找到数组成员"><a href="#es6-find-findindex-根据条件找到数组成员" class="header-anchor">#</a> ES6 find()&amp; findIndex() 根据条件找到数组成员</h6> <p>语法：arr.find(fn, thisArg)，arr.findIndex(fn, thisArg)</p> <div class="language- extra-class"><pre class="language-text"><code>find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。

findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。

这两个方法都可以识别NaN,弥补了indexOf的不足.

eg:
// find
let a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5
let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n));  // 返回元素NaN
// findIndex
let a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2
let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n));  // 返回索引4
</code></pre></div><h3 id="扩展运算符"><a href="#扩展运算符" class="header-anchor">#</a> 扩展运算符</h3> <div class="language- extra-class"><pre class="language-text"><code>扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

扩展运算符后面可以放置表达式。
console.log((...[1, 2]))
注意，扩展运算符如果放在括号中，JavaScript引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。
// Uncaught SyntaxError: Unexpected number

替代函数的 apply 方法
由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。

// ES5 的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
let args = [0, 1, 2];
f(...args);

下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。

// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);

另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。

// ES5的 写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6 的写法
let arr1 = [0, 1, 2];
let arr2 = [3, 4, 5];
arr1.push(...arr2);

还有一个小例子
// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);

扩展运算符的应用
（1）复制数组
    ES5:
    const a1 = [1, 2];
    const a2 = a1.concat();
    a2[0] = 2;
    a1 // [1, 2]

    使用扩展运算符：
    const a1 = [1, 2];
    // 写法一
    const a2 = [...a1];
    // 写法二
    const [...a2] = a1;

（2）合并数组
    const a1 = [{ foo: 1 }];
    const a2 = [{ bar: 2 }];

    const a3 = a1.concat(a2);
    const a4 = [...a1, ...a2];

    这两种方法都是浅拷贝
    a3[0] === a1[0] // true
    a4[0] === a1[0] // true

（3）与解构赋值结合
    // ES5
    a = list[0], rest = list.slice(1)
    // ES6
    [a, ...rest] = list

    const [first, ...rest] = [1, 2, 3, 4, 5];
    first // 1
    rest  // [2, 3, 4, 5]

    const [first, ...rest] = [];
    first // undefined
    rest  // []

    注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
    const [...butLast, last] = [1, 2, 3, 4, 5];
    // 报错

    const [first, ...middle, last] = [1, 2, 3, 4, 5];
    // 报错
（4）字符串
    扩展运算符还可以将字符串转为真正的数组。
    [...'hello']
    // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]

    'x\uD83D\uDE80y'.length // 4
    [...'x\uD83D\uDE80y'].length // 3
    上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，
    识别为 2 个字符，采用扩展运算符就没有这个问题。
    因此，正确返回字符串长度的函数，可以像下面这样写。
    function length(str) {
      return [...str].length;
    }
    length('x\uD83D\uDE80y') // 3

（5）实现了 Iterator 接口的对象
    任何定义了遍历器（Iterator）接口的对象都可以用扩展运算符转为真正的数组。

    下面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成
    Number实例以后，就会调用这个接口，就会返回自定义的结果。
    Number.prototype[Symbol.iterator] = function*() {
      let i = 0;
      let num = this.valueOf();
      while (i &lt; num) {
        yield i++;
      }
    }
    console.log([...5]) // [0, 1, 2, 3, 4]

    下面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口
    ，扩展运算符就会报错。
    let arrayLike = {
      '0': 'a',
      '1': 'b',
      '2': 'c',
      length: 3
    };
    // TypeError: Cannot spread non-iterable object.
    let arr = [...arrayLike];
（6）Map 和 Set 结构，Generator 函数
    扩展运算符内部调用的是数据结构的 Iterator 接口，
    因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。
    let map = new Map([
      [1, 'one'],
      [2, 'two'],
      [3, 'three'],
    ]);
    let arr = [...map.keys()]; // [1, 2, 3]

    Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。
    const go = function*(){
      yield 1;
      yield 2;
      yield 3;
    };
    [...go()] // [1, 2, 3]
    上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，
    对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。


</code></pre></div><h3 id="数组的空位"><a href="#数组的空位" class="header-anchor">#</a> 数组的空位</h3> <div class="language- extra-class"><pre class="language-text"><code>Array(3) // [, , ,]
空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。

0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false

ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。

forEach(), filter(), reduce(), every() 和some()都会跳过空位。
map()会跳过空位，但会保留这个值
join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。

// forEach方法
[,'a'].forEach((x,i) =&gt; console.log(i)); // 1

// filter方法
['a',,'b'].filter(x =&gt; true) // ['a','b']

// every方法
[,'a'].every(x =&gt; x==='a') // true

// reduce方法
[1,,2].reduce((x,y) =&gt; x+y) // 3

// some方法
[,'a'].some(x =&gt; x !== 'a') // false

// map方法
[,'a'].map(x =&gt; 1) // [,1]

// join方法
[,'a',undefined,null].join('#') // &quot;#a##&quot;

// toString方法
[,'a',undefined,null].toString() // &quot;,a,,&quot;


ES6 则是明确将空位转为undefined。

Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。
Array.from(['a',,'b'])
// [ &quot;a&quot;, undefined, &quot;b&quot; ]

扩展运算符（...）也会将空位转为undefined。
[...['a',,'b']]
// [ &quot;a&quot;, undefined, &quot;b&quot; ]

copyWithin()会连空位一起拷贝
[,'a','b',,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]

fill()会将空位视为正常的数组位置。
new Array(3).fill('a') // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]

for...of循环也会遍历空位。
let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1

entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。
// entries()
[...[,'a'].entries()] // [[0,undefined], [1,&quot;a&quot;]]

// keys()
[...[,'a'].keys()] // [0,1]

// values()
[...[,'a'].values()] // [undefined,&quot;a&quot;]

// find()
[,'a'].find(x =&gt; true) // undefined

// findIndex()
[,'a'].findIndex(x =&gt; true) // 0


</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.a8b9877c.js" defer></script><script src="/assets/js/38.07455d34.js" defer></script><script src="/assets/js/3.4266fc2a.js" defer></script><script src="/assets/js/181.48f4346f.js" defer></script>
  </body>
</html>
