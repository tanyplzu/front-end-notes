(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{517:function(a,t,n){"use strict";n.r(t);var s=n(5),e=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"数组操作方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组操作方法"}},[a._v("#")]),a._v(" 数组操作方法")]),a._v(" "),t("blockquote",[t("p",[a._v("同事的资料")])]),a._v(" "),t("h3",{attrs:{id:"构造数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造数组"}},[a._v("#")]),a._v(" 构造数组")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 字面量方式:")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//最常用的，简洁方便")]),a._v("\na"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// [empty × 3]")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用构造器:")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//[]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" c "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//[undefined × 3]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" d "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//[1,2,3]")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 数组长度最大为Math.pow(2,32)-1 ,即 4294967294 位")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 两种方式性能PK？")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" startTime "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getTime")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" num "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" num "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2000000")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" num"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("num"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" endTime "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getTime")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nconsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'new Array()输出耗时:'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" endTime "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" startTime"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//----------------------")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" startTime2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getTime")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" num2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" num2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2000000")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" num2"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  a2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("num2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" endTime2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getTime")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nconsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'[]输出耗时:'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" endTime2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" startTime2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//数十万数百万级")]),a._v("\n")])])]),t("h3",{attrs:{id:"es6-中新增的构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-中新增的构造方法"}},[a._v("#")]),a._v(" ES6 中新增的构造方法")]),a._v(" "),t("h4",{attrs:{id:"array-of"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#array-of"}},[a._v("#")]),a._v(" Array.of")]),a._v(" "),t("p",[a._v("Array.of 用于将参数依次转化为数组中的一项，然后返回这个新数组，而不管这个参数是数字还是其它。它基本上与 Array 构造器功能一致，唯一的区别就在单个数字参数的处理上。如下：")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[a._v("Array"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("of")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// [3]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// [undefined × 3]")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 参数为多个，或单个参数不是数字时，Array.of 与 Array构造器等同:")]),a._v("\nArray"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("of")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// [1, 2]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// [1, 2]")]),a._v("\nArray"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("of")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'8'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["8"]')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'8'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["8"]')]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 即使其他版本浏览器不支持也不必担心，由于Array.of与Array构造器的这种高度相似性，实现一个polyfill十分简单。如下：")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("Array"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("of"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  Array"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("of")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("slice")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("call")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("arguments"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//return [].slice.call(arguments);")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h4",{attrs:{id:"array-from"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#array-from"}},[a._v("#")]),a._v(" Array.from")]),a._v(" "),t("p",[a._v("语法：Array.from(arrayLike, processingFn, thisArg)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Array.from的设计初衷是快速便捷的基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象创建一个新的数组实例\n//简单来说，只要这个对象有迭代器，Array.from就能把它变成一个数组（当然，是返回新的数组，不改变原对象）。\n\n从语法上看，Array.from拥有3个形参，第一个为类似数组的对象，必选。第二个为加工函数，新生成的数组会经过该函数的加工再返回。第三个为this作用域，表示加工函数执行时this的值。后两个参数都是可选的。\n\nvar obj = {0: 'a', 1: 'b', 2:'c', length: 3};\nArray.from(obj, function(value, index){\n  console.log(value, index, this, arguments.length);\n  return value.repeat(2); //必须指定返回值，否则返回undefined\n  //加工函数变成箭头函数会怎么样？\n}, obj);//[\"aa\",\"bb\",\"cc\"]\n\n以上可简化为：\nArray.from(obj, (value) => value.repeat(2));\n\n生成一个从0到指定数字的新数组，Array.from就可以轻易的做到：\nArray.from({length: 10}, (v, i) => i); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n")])])]),t("h4",{attrs:{id:"array-isarray"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#array-isarray"}},[a._v("#")]),a._v(" Array.isArray")]),a._v(" "),t("p",[a._v("用来判断一个变量是否数组类型")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 我们至少有如下5种方式去判断一个值是否数组：")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1.基于instanceof")]),a._v("\na "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instanceof")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2.基于constructor")]),a._v("\na"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("constructor "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("===")]),a._v(" Array"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 3.基于Object.prototype.isPrototypeOf")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("isPrototypeOf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 4.基于getPrototypeOf")]),a._v("\nObject"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getPrototypeOf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("===")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 5.基于Object.prototype.toString")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("toString")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apply")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("===")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'[object Array]'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 但由于代码的运行环境十分复杂，加上JS的弱类型机制，导致可以随时手动指定了某个对象的__proto__：")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[a._v("__proto__")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 分别在控制台试运行以下代码")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1.基于instanceof")]),a._v("\na "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instanceof")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2.基于constructor")]),a._v("\na"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("constructor "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("===")]),a._v(" Array"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 3.基于Object.prototype.isPrototypeOf")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("isPrototypeOf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 4.基于getPrototypeOf")]),a._v("\nObject"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getPrototypeOf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("===")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//流氓继承方式，使上面的判断瞬间GG了")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 以上，除了Object.prototype.toString外，其它方法都不能正确判断变量的类型。")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用Array.isArray则非常简单")]),a._v("\nArray"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("isArray")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\nArray"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("isArray")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'a'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[a._v("length")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// false")]),a._v("\n")])])]),t("h3",{attrs:{id:"方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),t("p",[a._v("数组原型提供的方法非常之多，主要分为三种，一种是会改变自身值的，一种是不会改变自身值的，另外一种是遍历方法。")]),a._v(" "),t("p",[a._v("改变自身值的方法 (11 个），分别为"),t("strong",[a._v("unshift、shift、push、pop、splice、reverse、sort")]),a._v("，以及两个 ES6 新增的方法"),t("strong",[a._v("flat、flatMap、copyWithin")]),a._v(" 和 "),t("strong",[a._v("fill")]),a._v("。 "),t("strong",[a._v("unshift")]),a._v(" 语法：arr.unshift(element1, …, elementN)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('unshift() 方法用于在数组开始处插入一些元素(就像是栈底插入)，并返回数组新的长度。\n\nlet array = ["red", "green", "blue"];\nlet length = array.unshift("yellow");\nconsole.log(array); // ["yellow", "red", "green", "blue"]\nconsole.log(length); // 4\n')])])]),t("p",[t("strong",[a._v("shift")]),a._v(" 语法：arr.shift()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("shift()方法删除数组的第一个元素，并返回这个元素。\n\nlet array = [1,2,3,4,5];\nlet item = array.shift();\nconsole.log(array); // [2,3,4,5]\nconsole.log(item); // 1\n")])])]),t("h6",{attrs:{id:"push"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#push"}},[a._v("#")]),a._v(" push")]),a._v(" "),t("p",[a._v("语法：arr.push(element1, …, elementN)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度。\n\nlet array = ["football", "basketball", "volleyball"];\nlet i = array.push("Table tennis");\nconsole.log(array); // ["football", "basketball", "volleyball", "Table tennis"]\nconsole.log(i); // 4\n')])])]),t("h6",{attrs:{id:"pop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pop"}},[a._v("#")]),a._v(" pop")]),a._v(" "),t("p",[a._v("语法：arr.pop()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。\n\nlet array = ["cat", "dog", "cow", "chicken", "mouse"];\nlet item = array.pop();\nconsole.log(array); // ["cat", "dog", "cow", "chicken"]\nconsole.log(item); // mouse\n')])])]),t("h6",{attrs:{id:"splice"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#splice"}},[a._v("#")]),a._v(" splice")]),a._v(" "),t("p",[a._v("语法：arr.splice(start,deleteCount,[item1, item2, …])")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('splice()方法用新元素替换旧元素的方式来修改数组。\n\nstart 指定从哪一位开始修改内容。如果超过了数组长度，则从数组末尾开始添加内容；如果是负值，则其指定的索引位置等同于 length+start (length为数组的长度)，表示从数组末尾开始的第 -start 位。\ndeleteCount 指定要删除的元素个数，若等于0，则不删除。这种情况下，至少应该添加一位新元素，若大于start之后的元素总和，则start及之后的元素都将被删除。\nitemN 指定新增的元素，如果缺省，则该方法只删除数组元素。\n返回值 由原数组中被删除元素组成的数组，如果没有删除，则返回一个空数组。\n\nlet array = ["apple","boy"];\nlet splices = array.splice(-3,1,"cat");\nconsole.log(array); // ["cat", "boy"]\nconsole.log(splices); // ["apple"], 可见即使-start超出数组长度,数组默认从首位开始删除\n------\nlet array = ["apple","boy"];\nlet splices = array.splice(3,3,"cat");\nconsole.log(array); // ["cat"]\nconsole.log(splices); // ["apple", "boy"]\n可见当start超出数组长度，数组没变化，默认从末尾该添加啥添加啥\n')])])]),t("h6",{attrs:{id:"reverse"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reverse"}},[a._v("#")]),a._v(" reverse")]),a._v(" "),t("p",[a._v("语法：arr.reverse()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("reverse()方法颠倒数组中元素的位置，第一个会成为最后一个，最后一个会成为第一个，该方法返回对数组的引用。\n\nlet array = [1,2,3,4,5];\nlet array2 = array.reverse();\nconsole.log(array); // [5,4,3,2,1]\nconsole.log(array2===array); // true\n")])])]),t("h6",{attrs:{id:"sort"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sort"}},[a._v("#")]),a._v(" sort")]),a._v(" "),t("p",[a._v("语法：arr.sort([comparefn])")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('sort()方法对数组元素进行排序，并返回这个数组。\n\ncomparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序，例如”Boy”将排到”apple”之前。当对数字排序的时候，25将会排到8之前，因为转换为字符串后，”25”将比”8”靠前。例如：\n\nlet array = ["Boy","apple","Cat","dog"];\nlet array2 = array.sort();\nconsole.log(array); // ["Boy", "Cat", "apple", "dog"]\nconsole.log(array2 == array); // true\nlet array3 = array.sort((a, b) => a.localeCompare(b));\nconsole.log(array3)//["apple", "Boy", "Cat", "dog"]\n\nlet array = [10, 1, 3, 20];\nlet array1 = array.sort();\nconsole.log(array1); // [1, 10, 20, 3]\nlet array2 = array.sort((a, b) => a-b);\nconsole.log(array2)//[1, 3, 10, 20]\n\n实际上，ECMAscript规范中并未规定具体的sort算法，这就势必导致各个浏览器不尽相同的sort算法，请看sort方法在Chrome浏览器下表现：\n\nlet array = [{ n: "a", v: 1 }, { n: "b", v: 1 }, { n: "c", v: 1 }, { n: "d", v: 1 }, { n: "e", v: 1 }, { n: "f", v: 1 }, { n: "g", v: 1 }, { n: "h", v: 1 }, { n: "i", v: 1 }, { n: "j", v: 1 }, { n: "k", v: 1 }, ];\narray.sort((a, b) => return a.v - b.v);\nfor (let i = 0,len = array.length; i < len; i++) {\n    console.log(array[i].n);\n}\n\n由于v值相等，array数组排序前后应该不变，然而Chrome却表现异常，而其他浏览器(如IE 或 Firefox) 表现正常。\n这是因为v8引擎为了高效排序(采用了不稳定排序)。即数组长度超过10条时，会调用另一种排序方法(快速排序)；而10条及以下采用的是插入排序，此时结果将是稳定的。\n\n解决办法：\n// 由于快速排序会打乱值相同的元素的默认排序，因此我们需要先标记元素的默认位置\narray.forEach((v, k) =>v.__index = k);\n// 由于__index标记了初始顺序，这样的返回才保证了值相同元素的顺序不变，进而使得排序稳定\narray.sort((a, b) => return a.v - b.v || a.__index - b.__index);\n\n值得注意的是:\n各浏览器的针对sort方法内部算法实现不尽相同，排序函数尽量只返回-1、0、1三种不同的值，不要尝试返回true或false等其它数值，因为可能导致不可靠的排序结果。\n\nlet array = [7, 6, 5, 4, 3, 2, 1, 0, 10, 9, 8];\nlet comparefn = (x, y) => x > y;\narray.sort(comparefn);\n')])])]),t("h6",{attrs:{id:"flat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flat"}},[a._v("#")]),a._v(" flat")]),a._v(" "),t("p",[a._v("语法：arr.flat(depth)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\n\nvar arr1 = [1, 2, [3, 4]];\narr1.flat();\n// [1, 2, 3, 4]\n\nvar arr2 = [1, 2, [3, 4, [5, 6]]];\narr2.flat(2);\n// [1, 2, 3, 4, 5, 6]\n\n//使用 Infinity 作为深度，展开任意深度的嵌套数组\narr2.flat(Infinity);\n// [1, 2, 3, 4, 5, 6]\n\nvar arr4 = [1, 2, , 4, 5];\narr4.flat(); //flat() 方法会移除数组中的空项:\n// [1, 2, 4, 5]\n")])])]),t("h6",{attrs:{id:"flatmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flatmap"}},[a._v("#")]),a._v(" flatMap")]),a._v(" "),t("p",[a._v("语法：arr.flat(fn,thisArg)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。\n\nvar arr1 = [1, 2, 3, 4];\n\narr1.flatMap(x => [x * 2]);\n// [2, 4, 6, 8]\n\n// 只会将 flatMap 中的函数返回的数组 “压平” 一层\narr1.flatMap(x => [[x * 2]]);\n// [[2], [4], [6], [8]]\n")])])]),t("h6",{attrs:{id:"copywithin-es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copywithin-es6"}},[a._v("#")]),a._v(" copyWithin(ES6)")]),a._v(" "),t("p",[a._v("语法：arr.copyWithin(target, start, end)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("copyWithin() 方法基于ECMAScript 2015（ES6）规范，用于数组内元素之间的替换，即替换元素和被替换元素均是数组内的元素。\n其中，taget 指定被替换元素的索引，start 指定替换元素起始的索引，end 可选，指的是替换元素结束位置的索引。\n如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。\n\nlet array = [1,2,3,4,5];\nlet array2 = array.copyWithin(0,3);\nconsole.log(array===array2,array2); // true [4, 5, 3, 4, 5]\n\nlet array = [1,2,3,4,5];\nconsole.log(array.copyWithin(0,3,4)); // [4, 2, 3, 4, 5]\n\nlet array = [1,2,3,4,5];\nconsole.log(array.copyWithin(0,-2,-1)); // [4, 2, 3, 4, 5]\n")])])]),t("h6",{attrs:{id:"fill-es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fill-es6"}},[a._v("#")]),a._v(" fill(ES6)")]),a._v(" "),t("p",[a._v("语法：arr.fill(value, start, end)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("fill() 方法基于ECMAScript 2015（ES6）规范，它同样用于数组元素替换，但与copyWithin略有不同，它主要用于将数组指定区间内的元素替换为某个值。\n其中，value 指定被替换的值，start 指定替换元素起始的索引，end 可选，指的是替换元素结束位置的索引。\n如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。\n\nlet array = [1,2,3,4,5];\nlet array2 = array.fill(10,0,3);\nconsole.log(array===array2,array2); // true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10\n")])])]),t("p",[a._v("不会改变自身的方法 (9 个），分别为"),t("strong",[a._v("concat、join、slice、toString、toLocateString、indexOf、lastIndexOf、"),t("strong",[a._v("未标准的")]),a._v("toSource")]),a._v("以及 ES7 新增的方法"),t("strong",[a._v("includes")]),a._v("。")]),a._v(" "),t("h6",{attrs:{id:"concat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concat"}},[a._v("#")]),a._v(" concat")]),a._v(" "),t("p",[a._v("语法：arr.concat(value1, value2, …, valueN)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("concat() 方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回。\n\nlet array = [1, 2, 3];\nlet array2 = array.concat(4,[5,6],[7,8,9]);\nconsole.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(array); // [1, 2, 3], 可见原数组并未被修改\n\n若concat方法中不传入参数，那么将基于原数组浅复制生成一个一模一样的新数组（指向新的地址空间）。\n\nlet array = [{a: 1}];\nlet array3 = array.concat();\nconsole.log(array3); // [{a: 1}]\nconsole.log(array3 === array); // false\nconsole.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用\n\n")])])]),t("h6",{attrs:{id:"join"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#join"}},[a._v("#")]),a._v(" join")]),a._v(" "),t("p",[a._v("语法：arr.join([separator = ‘,’]) separator 可选，缺省默认为逗号。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("join() 方法将数组中的所有元素连接成一个字符串。\n\nlet array = ['We', 'are', 'Chinese'];\nconsole.log(array.join()); // \"We,are,Chinese\"\nconsole.log(array.join('+')); // \"We+are+Chinese\"\nconsole.log(array.join('')); // \"WeareChinese\"\n")])])]),t("h6",{attrs:{id:"slice"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#slice"}},[a._v("#")]),a._v(" slice")]),a._v(" "),t("p",[a._v("语法：arr.slice(start, end)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('slice() 方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。\n参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。\n\n如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。\n\nslice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。\n\nlet array = ["one", "two", "three","four", "five"];\nconsole.log(array.slice()); // ["one", "two", "three","four", "five"]\nconsole.log(array.slice(2,3)); // ["three"]\n\nlet array = [{color:"yellow"}, 2, 3];\nlet array2 = array.slice(0,1);\nconsole.log(array2); // [{color:"yellow"}]\narray[0]["color"] = "blue";\nconsole.log(array2); // [{color:"bule"}]\n\n')])])]),t("h6",{attrs:{id:"tostring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tostring"}},[a._v("#")]),a._v(" toString")]),a._v(" "),t("p",[a._v("语法：arr.toString()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("toString() 方法返回数组的字符串形式，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。\n\nlet array = ['Jan', 'Feb', 'Mar', 'Apr'];\nlet str = array.toString();\nconsole.log(str); // Jan,Feb,Mar,Apr\n")])])]),t("h6",{attrs:{id:"tolocalestring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tolocalestring"}},[a._v("#")]),a._v(" toLocaleString")]),a._v(" "),t("p",[a._v("语法：arr.toLocaleString()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('toLocaleString() 类似toString()的变型，该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。\n\nlet array= [{name:\'zz\'}, 123, "abc", new Date()];\nlet str = array.toLocaleString();\nconsole.log(str); // [object Object],123,abc,2019/3/28 下午12:16:23\n\ntoString()和toLocaleString()两点区别：\n\n1.当数字是四位数及以上时\n    let a=1234.5678\n    a.toString()//"1234.5678"\n    a.toLocaleString()//"1,234.568"\n2.当目标是标准时间格式时\n    let sd=new Date()//Thu Mar 07 2019 12:11:55 GMT+0800 (中国标准时间)\n    sd.toLocaleString()//"2019/3/7 下午12:21:55"\n    sd.toString()//Thu Mar 07 2019 12:11:55 GMT+0800\n')])])]),t("h6",{attrs:{id:"indexof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#indexof"}},[a._v("#")]),a._v(" indexOf")]),a._v(" "),t("p",[a._v("语法：arr.indexOf(element, fromIndex=0)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("indexOf() 方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1。\n\nelement 为需要查找的元素,fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + fromIndex项开始往数组末尾查找，如果length + fromIndex<0 则整个数组都会被查找。\n\nlet array = ['abc', 'def', 'ghi','123'];\nconsole.log(array.indexOf('def')); // 1\nconsole.log(array.indexOf('def',-1)); // -1 此时表示从最后一个元素往后查找,因此查找失败返回-1\nconsole.log(array.indexOf('def',-4)); // 1 由于4大于数组长度,此时将查找整个数组,因此返回1\nconsole.log(array.indexOf(123)); // -1, 由于是严格匹配,因此并不会匹配到字符串'123'\n")])])]),t("h6",{attrs:{id:"lastindexof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lastindexof"}},[a._v("#")]),a._v(" lastIndexOf")]),a._v(" "),t("p",[a._v("语法：arr.lastIndexOf(element, fromIndex=length-1)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("lastIndexOf() 方法用于查找元素在数组中最后一次出现时的索引，如果没有，则返回-1。并且它是indexOf的逆向查找，即从数组最后一个往前查找。\n\nelement 为需要查找的元素,fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + fromIndex项开始往数组末尾查找，如果length + fromIndex<0 则整个数组都会被查找。\n\n同 indexOf 一样，lastIndexOf 也是严格匹配数组元素。\n")])])]),t("h6",{attrs:{id:"includes-es7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#includes-es7"}},[a._v("#")]),a._v(" includes(ES7)")]),a._v(" "),t("p",[a._v("语法：arr.includes(element, fromIndex=0)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("includes() 方法基于ECMAScript 2016（ES7）规范，它用来判断当前数组是否包含某个指定的值，如果是，则返回 true，否则返回 false。\n\nelement 为需要查找的元素,fromIndex 表示从该索引位置开始查找 element，缺省为0，它是正向查找，即从索引处往数组末尾查找。\n\nlet array = [0, 1, 2];\nconsole.log(array.includes(0)); // true\nconsole.log(array.includes(1)); // true\nconsole.log(array.includes(2,-4)); // true\n\n你可能会问，既然有了indexOf方法，为什么又造一个includes方法，arr.indexOf(x)>-1不就等于arr.includes(x)？看起来是的，几乎所有的时候它们都等同，唯一的区别就是includes能够发现NaN，而indexOf不能。\n\nlet array = [NaN];\nconsole.log(array.includes(NaN)); // true\nconsole.log(arra.indexOf(NaN)>-1); // false\n")])])]),t("h6",{attrs:{id:"tosource-非标准"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tosource-非标准"}},[a._v("#")]),a._v(" toSource（非标准）")]),a._v(" "),t("p",[a._v("语法：arr.toSource()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('toSource() 方法是非标准的，该方法返回数组的源代码\n\nlet array = [\'a\', \'b\', \'c\'];\nconsole.log(array.toSource()); // ["a", "b", "c"]\n\n只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。\n\nfunction employee(name,job,born)\n{\nthis.name=name;\nthis.job=job;\nthis.born=born;\n}\n\nvar bill=new employee("Bill Gates","Engineer",1985);\n\ndocument.write(bill.toSource());\n//({name:"Bill Gates", job:"Engineer", born:1985})\n')])])]),t("p",[a._v("遍历方法 (12 个）基于 ES6，不会改变自身的方法一共有 12 个，分别为"),t("strong",[a._v("forEach、every、some、filter、map、reduce、reduceRight")]),a._v(" 以及 ES6 新增的方法"),t("strong",[a._v("entries、find、findIndex、keys、values")]),a._v("。")]),a._v(" "),t("h6",{attrs:{id:"foreach"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#foreach"}},[a._v("#")]),a._v(" forEach")]),a._v(" "),t("p",[a._v("语法：arr.forEach(fn, thisArg)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("forEach() 方法指定数组的每项元素都执行一次传入的函数，返回值为undefined。\n\nfn 表示在数组每一项上执行的函数，接受三个参数：\nvalue 当前正在被处理的元素的值\nindex 当前元素的数组索引\narray 数组本身\nthisArg 可选，用来当做fn函数内的this对象。\n\nforEach 将为数组中每一项执行一次 fn 函数，那些已删除，新增或者从未赋值的项将被跳过（但不包括值为 undefined 的项）。\n\nlet array = [1, 3, 5];\nlet obj = {name:'cc'};\nlet sReturn = array.forEach(function(value, index, array){\n  array[index] = value * value;\n  console.log(this.name); // cc被打印了三次\n},obj);\nconsole.log(array); // [1, 9, 25], 可见原数组改变了\nconsole.log(sReturn); // undefined, 可见返回值为undefined\n\n*forEach无法直接退出循环，只能使用return 来达到for循环中continue的效果\n*它总是返回 undefined值,即使你return了一个值。\n\n1. 对于空数组是不会执行回调函数的\n2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数\n3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。\n4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。\neg:\nlet a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)\nlet obj = { name: 'obj的名字' };\nlet result = a.forEach(function (value, index, array) {\n    a[3] = '改变元素';\n    a.push('添加到尾端，不会被遍历')\n    console.log(value, 'forEach传递的第一个参数'); // 分别打印 1 ,2 ,改变元素\n    console.log(this.name); // 'obj的名字' 打印三次 this绑定在obj对象上\n    // break; // break会报错\n    return value; // return只能结束本次回调 会执行下次回调\n    console.log('不会执行，因为return 会执行下一次循环回调')\n}, obj);\nconsole.log(result); // 即使return了一个值,也还是返回undefined\n")])])]),t("h6",{attrs:{id:"every"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#every"}},[a._v("#")]),a._v(" every")]),a._v(" "),t("p",[a._v("语法：arr.every(fn, thisArg)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("every()方法检测数组所有元素是否都符合判断条件（参数同上)\n\n方法返回值规则:\n1 ，如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测\n2. 如果所有元素都满足条件，则返回 true\n\neg:\nfunction isBigEnough(element, index, array) {\n  return element >= 10; // 判断数组中的所有元素是否都大于10\n}\n[12, 5, 8, 130, 44].every(x => x >= 10); // false\n[12, 54, 18, 130, 44].every(x => x >= 10); // true\n")])])]),t("h6",{attrs:{id:"some"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#some"}},[a._v("#")]),a._v(" some")]),a._v(" "),t("p",[a._v("语法：arr.some(fn, thisArg)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("some()数组中的是否有满足判断条件的元素（参数同上)\n\n方法返回值规则:\n1 ，如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测\n2. 如果没有满足条件的元素，则返回false\n\neg:\nfunction isBigEnough(element, index, array) {\n   return (element >= 10); //数组中是否有一个元素大于 10\n}\nlet result = [2, 5, 8, 1, 4].some(isBigEnough); // false\nlet result = [12, 5, 8, 1, 4].some(isBigEnough); // true\n")])])]),t("h6",{attrs:{id:"filter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#filter"}},[a._v("#")]),a._v(" filter")]),a._v(" "),t("p",[a._v("语法：arr.filter(fn, thisArg)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("filter()过滤原始数组，返回通过所提供函数实现的所有元素组成的新数组（参数同上)\n\neg:\nlet a = [32, 33, 16, 40];\nlet result = a.filter(function (value, index, array) {\n  return value >= 18; // 返回a数组中所有大于18的元素\n});\nconsole.log(result,a);// [32,33,40] [32,33,16,40]\n")])])]),t("h6",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" map")]),a._v(" "),t("p",[a._v("语法：arr.map(fn, thisArg)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("map()对数组中的每个元素进行处理，返回新的数组（参数同上)\n\neg:\nlet a = ['1','2','3','4'];\nlet result = a.map(function (value, index, array) {\n  return value + 0\n});\nconsole.log(result); /[\"10\", \"20\", \"30\", \"40\"]\n")])])]),t("h6",{attrs:{id:"reduce"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[a._v("#")]),a._v(" reduce")]),a._v(" "),t("p",[a._v("语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("reduce()为数组提供累加器，合并为一个值\n\n1. 如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值\n2. 如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError\n3. 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回\n\neg:\n// 数组求和\nlet sum = [0, 1, 2, 3].reduce(function (a, b) {\n  return a + b;\n}, 0);\n// 6\n------\n// 将二维数组转化为一维 将数组元素展开//见flat()\nlet flattened = [[0, 1], [2, 3], [4, 5]].reduce((a, b) => a.concat(b),[]);\n // [0, 1, 2, 3, 4, 5]\n")])])]),t("h6",{attrs:{id:"reduceright"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reduceright"}},[a._v("#")]),a._v(" reduceRight")]),a._v(" "),t("p",[a._v("语法：array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("这个方法除了与reduce执行方向相反外，其他完全与其一致\n")])])]),t("h6",{attrs:{id:"es6-keys-values-entries-遍历键名、遍历键值、遍历键名-键值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-keys-values-entries-遍历键名、遍历键值、遍历键名-键值"}},[a._v("#")]),a._v(" ES6 keys()&values()&entries() 遍历键名、遍历键值、遍历键名 + 键值")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值\n\neg:\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n\n在for..of中如果遍历中途要退出，可以使用break退出循环。\n\n如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历:\n\nlet letter = ['a', 'b', 'c'];\nlet entries = letter.entries();\nconsole.log(entries.next().value); // [0, 'a']\nconsole.log(entries.next().value); // [1, 'b']\nconsole.log(entries.next().value); // [2, 'c']\n")])])]),t("h6",{attrs:{id:"es6-find-findindex-根据条件找到数组成员"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-find-findindex-根据条件找到数组成员"}},[a._v("#")]),a._v(" ES6 find()& findIndex() 根据条件找到数组成员")]),a._v(" "),t("p",[a._v("语法：arr.find(fn, thisArg)，arr.findIndex(fn, thisArg)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。\n\nfindIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\n\n这两个方法都可以识别NaN,弥补了indexOf的不足.\n\neg:\n// find\nlet a = [1, 4, -5, 10].find((n) => n < 0); // 返回元素-5\nlet b = [1, 4, -5, 10,NaN].find((n) => Object.is(NaN, n));  // 返回元素NaN\n// findIndex\nlet a = [1, 4, -5, 10].findIndex((n) => n < 0); // 返回索引2\nlet b = [1, 4, -5, 10,NaN].findIndex((n) => Object.is(NaN, n));  // 返回索引4\n")])])]),t("h3",{attrs:{id:"扩展运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展运算符"}},[a._v("#")]),a._v(" 扩展运算符")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n扩展运算符后面可以放置表达式。\nconsole.log((...[1, 2]))\n注意，扩展运算符如果放在括号中，JavaScript引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。\n// Uncaught SyntaxError: Unexpected number\n\n替代函数的 apply 方法\n由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。\n\n// ES5 的写法\nfunction f(x, y, z) {\n  // ...\n}\nvar args = [0, 1, 2];\nf.apply(null, args);\n\n// ES6的写法\nfunction f(x, y, z) {\n  // ...\n}\nlet args = [0, 1, 2];\nf(...args);\n\n下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。\n\n// ES5 的写法\nMath.max.apply(null, [14, 3, 77])\n\n// ES6 的写法\nMath.max(...[14, 3, 77])\n\n// 等同于\nMath.max(14, 3, 77);\n\n另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。\n\n// ES5的 写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nArray.prototype.push.apply(arr1, arr2);\n\n// ES6 的写法\nlet arr1 = [0, 1, 2];\nlet arr2 = [3, 4, 5];\narr1.push(...arr2);\n\n还有一个小例子\n// ES5\nnew (Date.bind.apply(Date, [null, 2015, 1, 1]))\n// ES6\nnew Date(...[2015, 1, 1]);\n\n扩展运算符的应用\n（1）复制数组\n    ES5:\n    const a1 = [1, 2];\n    const a2 = a1.concat();\n    a2[0] = 2;\n    a1 // [1, 2]\n\n    使用扩展运算符：\n    const a1 = [1, 2];\n    // 写法一\n    const a2 = [...a1];\n    // 写法二\n    const [...a2] = a1;\n\n（2）合并数组\n    const a1 = [{ foo: 1 }];\n    const a2 = [{ bar: 2 }];\n\n    const a3 = a1.concat(a2);\n    const a4 = [...a1, ...a2];\n\n    这两种方法都是浅拷贝\n    a3[0] === a1[0] // true\n    a4[0] === a1[0] // true\n\n（3）与解构赋值结合\n    // ES5\n    a = list[0], rest = list.slice(1)\n    // ES6\n    [a, ...rest] = list\n\n    const [first, ...rest] = [1, 2, 3, 4, 5];\n    first // 1\n    rest  // [2, 3, 4, 5]\n\n    const [first, ...rest] = [];\n    first // undefined\n    rest  // []\n\n    注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n    const [...butLast, last] = [1, 2, 3, 4, 5];\n    // 报错\n\n    const [first, ...middle, last] = [1, 2, 3, 4, 5];\n    // 报错\n（4）字符串\n    扩展运算符还可以将字符串转为真正的数组。\n    [...'hello']\n    // [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\n    'x\\uD83D\\uDE80y'.length // 4\n    [...'x\\uD83D\\uDE80y'].length // 3\n    上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，\n    识别为 2 个字符，采用扩展运算符就没有这个问题。\n    因此，正确返回字符串长度的函数，可以像下面这样写。\n    function length(str) {\n      return [...str].length;\n    }\n    length('x\\uD83D\\uDE80y') // 3\n\n（5）实现了 Iterator 接口的对象\n    任何定义了遍历器（Iterator）接口的对象都可以用扩展运算符转为真正的数组。\n\n    下面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成\n    Number实例以后，就会调用这个接口，就会返回自定义的结果。\n    Number.prototype[Symbol.iterator] = function*() {\n      let i = 0;\n      let num = this.valueOf();\n      while (i < num) {\n        yield i++;\n      }\n    }\n    console.log([...5]) // [0, 1, 2, 3, 4]\n\n    下面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口\n    ，扩展运算符就会报错。\n    let arrayLike = {\n      '0': 'a',\n      '1': 'b',\n      '2': 'c',\n      length: 3\n    };\n    // TypeError: Cannot spread non-iterable object.\n    let arr = [...arrayLike];\n（6）Map 和 Set 结构，Generator 函数\n    扩展运算符内部调用的是数据结构的 Iterator 接口，\n    因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。\n    let map = new Map([\n      [1, 'one'],\n      [2, 'two'],\n      [3, 'three'],\n    ]);\n    let arr = [...map.keys()]; // [1, 2, 3]\n\n    Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。\n    const go = function*(){\n      yield 1;\n      yield 2;\n      yield 3;\n    };\n    [...go()] // [1, 2, 3]\n    上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，\n    对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。\n\n\n")])])]),t("h3",{attrs:{id:"数组的空位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组的空位"}},[a._v("#")]),a._v(" 数组的空位")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Array(3) // [, , ,]\n空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。\n\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n\nES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。\n\nforEach(), filter(), reduce(), every() 和some()都会跳过空位。\nmap()会跳过空位，但会保留这个值\njoin()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。\n\n// forEach方法\n[,'a'].forEach((x,i) => console.log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// reduce方法\n[1,,2].reduce((x,y) => x+y) // 3\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a##\"\n\n// toString方法\n[,'a',undefined,null].toString() // \",a,,\"\n\n\nES6 则是明确将空位转为undefined。\n\nArray.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。\nArray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n\n扩展运算符（...）也会将空位转为undefined。\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n\ncopyWithin()会连空位一起拷贝\n[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]\n\nfill()会将空位视为正常的数组位置。\nnew Array(3).fill('a') // [\"a\",\"a\",\"a\"]\n\nfor...of循环也会遍历空位。\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n\nentries()、keys()、values()、find()和findIndex()会将空位处理成undefined。\n// entries()\n[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]\n\n// keys()\n[...[,'a'].keys()] // [0,1]\n\n// values()\n[...[,'a'].values()] // [undefined,\"a\"]\n\n// find()\n[,'a'].find(x => true) // undefined\n\n// findIndex()\n[,'a'].findIndex(x => true) // 0\n\n\n")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);