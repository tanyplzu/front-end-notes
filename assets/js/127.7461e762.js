(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{463:function(t,s,a){"use strict";a.r(s);var e=a(5),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"node基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node基础"}},[t._v("#")]),t._v(" Node基础")]),t._v(" "),s("h2",{attrs:{id:"怎么看-nodejs-可支持高并发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么看-nodejs-可支持高并发"}},[t._v("#")]),t._v(" 怎么看 nodejs 可支持高并发")]),t._v(" "),s("ol",[s("li",[t._v("nodejs 的单线程架构模型")])]),t._v(" "),s("p",[t._v("nodejs 其实并不是真正的单线程架构，因为 nodejs 还有 I/O 线程存在（网络 I/O、磁盘 I/O），这些 I/O 线程是由更底层的 libuv 处理，这部分线程对于开发者来说是透明的。 JavaScript 代码永远运行在 V8 上，是单线程的。所以从开发者的角度上来看 nodejs 是单线程的。")]),t._v(" "),s("p",[t._v("优势：")]),t._v(" "),s("p",[t._v("单线程就一个线程在玩，省去了线程间切换的开销还有线程同步的问题，线程冲突的问题的也不需要担心")]),t._v(" "),s("p",[t._v("劣势：")]),t._v(" "),s("p",[t._v("劣势也很明显，现在起步都是 4 核，单线程没法充分利用 cpu 的资源单线程，一旦崩溃，应用就挂掉了，大家调试脚本也知道一旦执行过程报错了，本次调试就直接结束了因为只能利用一个 cpu ，一旦 cpu 被某个计算一直占用， cpu 得不到释放，后续的请求就会一直被挂起，直接无响应了")]),t._v(" "),s("blockquote",[s("p",[t._v("当然这些劣势都已经有成熟的解决方案了，使用 PM2 管理进程，或者上 K8S 也可以")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("核心：事件循环机制")])]),t._v(" "),s("p",[t._v("那你个单线程怎么支持高并发呢？核心就要在于 js 引擎的事件循环机制。对高密集性 I/O 还可以。浏览器和 nodejs 的事件循环是稍有区别的。")]),t._v(" "),s("h2",{attrs:{id:"node-事件轮询中的几个阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-事件轮询中的几个阶段"}},[t._v("#")]),t._v(" Node 事件轮询中的几个阶段")]),t._v(" "),s("blockquote",[s("p",[t._v("event loop 首先会在内部维持多个事件队列，比如 时间队列、网络队列等等，而 libuv 会执行一个相当于 while true 的无限循环，不断的检查各个事件队列上面是否有需要处理的 pending 状态事件，如果有则按顺序去触发队列里面保存的事件，同时由于 libuv 的事件循环每次只会执行一个回调，从而避免了 竞争的发生")])]),t._v(" "),s("p",[t._v("事件循环必须跑完这六个阶段才算一个轮回")]),t._v(" "),s("p",[t._v("每个阶段都有一个回调函数 FIFO（先进先出）队列。EL 进入一个阶段会执行里面所有的操作，然后执行回调函数，直到队列消耗尽，或是回调函数执行数量达到最大限制。清理 nextTickQueue/microtasks 之后进入下一个阶段")]),t._v(" "),s("p",[t._v("阶段里的执行队列：")]),t._v(" "),s("ul",[s("li",[t._v("Timers Queue "),s("code",[t._v("setTimeout()")]),t._v(" "),s("code",[t._v("setInterval()")]),t._v("设定的回调函数")]),t._v(" "),s("li",[t._v("I/O Queue 几乎所有的回调，除了 timers、close callbacks、check 阶段的回调")]),t._v(" "),s("li",[t._v("Check Queue "),s("code",[t._v("setImmediate()")]),t._v(" 设定的回调函数")]),t._v(" "),s("li",[t._v("Close Queue 比如 "),s("code",[t._v("socket.on('close', ...)")])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("   ┌───────────────────────┐\n┌─>│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │<─────┤  connections, │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\n")])])]),s("h3",{attrs:{id:"timers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#timers"}},[t._v("#")]),t._v(" timers")]),t._v(" "),s("p",[t._v("在这个阶段检查是否有到达阈值的 timer(setTimeout/setInterval)，有的话就执行他们的回调")]),t._v(" "),s("p",[t._v("但 timer 设定的阈值不是执行回调的确切时间（只是最短的间隔时间），node 内核调度机制和其他的回调函数会推迟它的执行")]),t._v(" "),s("p",[t._v("由 poll 阶段来控制什么时候执行 timers callbacks")]),t._v(" "),s("h3",{attrs:{id:"i-o-callbacks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#i-o-callbacks"}},[t._v("#")]),t._v(" I/O callbacks")]),t._v(" "),s("p",[t._v("处理异步事件的回调，比如网络 I/O，比如文件读取 I/O。当这些 I/O 动作都结束的时候，在这个阶段会触发它们的回调。")]),t._v(" "),s("h3",{attrs:{id:"idle-prepare-内部使用-忽略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#idle-prepare-内部使用-忽略"}},[t._v("#")]),t._v(" "),s("s",[t._v("idle, prepare 内部使用，忽略")])]),t._v(" "),s("h3",{attrs:{id:"poll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[t._v("#")]),t._v(" poll")]),t._v(" "),s("p",[t._v("获取新的 I/O 事件，node 会在适当的情况下阻塞在这里")]),t._v(" "),s("p",[t._v("为防止 poll phase 耗尽 event loop，libuv 也有一个最大值（基于系统），会在超过最大值之后停止轮询更多的事件")]),t._v(" "),s("p",[t._v('由于其它各个阶段的操作都有可能导致新的事件发生，并使得内核向 poll queue 中添加事件，所以在 poll 阶段处理事件的时候可能还会有新的事件产生，最终，长时间的调用回调函数将会导致定时器过期，所以在 poll 阶段与定时器会有"合作"')]),t._v(" "),s("p",[t._v("poll 阶段主要的两个功能：")]),t._v(" "),s("ul",[s("li",[t._v("处理 poll queue 的 callbacks")]),t._v(" "),s("li",[t._v("回到 timers phase 执行 timers callbacks（当到达 timers 指定的时间时）")])]),t._v(" "),s("p",[t._v("进入 poll 阶段，timer 的设定有下面两种情况：")]),t._v(" "),s("ol",[s("li",[t._v("event loop 进入了 poll 阶段，"),s("strong",[t._v("未设定 timer")]),t._v(" "),s("ul",[s("li",[t._v("poll queue 不为空：\n"),s("ul",[s("li",[t._v("event loop 将同步的执行 queue 里的 callback，直到清空或执行的 callback 到达系统上限")])])]),t._v(" "),s("li",[t._v("poll queue 为空\n"),s("ul",[s("li",[t._v("如果有设定 setImmediate() callback, event loop 将结束 poll 阶段进入 check 阶段，并执行 check queue (check queue 是 setImmediate 设定的）")]),t._v(" "),s("li",[t._v("如果代码没有设定 setImmediate() callback，event loop 将阻塞在该阶段等待 callbacks 加入 poll queue")])])])])]),t._v(" "),s("li",[t._v("event loop 进入了 poll 阶段，"),s("strong",[t._v("设定了 timer")]),t._v(" "),s("ul",[s("li",[t._v("如果 poll 进入空闲状态，event loop 将检查 timers，如果有 1 个或多个 timers 时间时间已经到达，event loop 将回到 timers 阶段执行 timers queue")])])])]),t._v(" "),s("h3",{attrs:{id:"check"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#check"}},[t._v("#")]),t._v(" check")]),t._v(" "),s("ul",[s("li",[t._v("一旦 poll 队列闲置下来或者是代码被 setImmediate 调度，EL 会马上进入 check phase")]),t._v(" "),s("li",[t._v("check 是特殊的 timer")])]),t._v(" "),s("h3",{attrs:{id:"close-callbacks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#close-callbacks"}},[t._v("#")]),t._v(" close callbacks")]),t._v(" "),s("ul",[s("li",[t._v("关闭 I/O 的动作，比如文件描述符的关闭，连接断开等")]),t._v(" "),s("li",[t._v("如果 socket 突然中断，close 事件会在这个阶段被触发")])]),t._v(" "),s("h3",{attrs:{id:"看个例子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#看个例子"}},[t._v("#")]),t._v(" 看个例子~")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" fs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fs'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("someAsyncOperation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("callback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 假设用了95ms")]),t._v("\n  fs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("readFile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/path/to/file'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" callback"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" timeoutScheduled "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Date"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" delay "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Date"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" timeoutScheduled"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("delay "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'ms have passed since I was scheduled'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("someAsyncOperation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" startCallback "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Date"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Date"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" startCallback "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// log: 105ms have passed since I was scheduled")]),t._v("\n")])])]),s("ol",[s("li",[t._v("timers：定时器加入到 timers queue 中，定时的时间设置为 100ms，进入下阶段")]),t._v(" "),s("li",[t._v("I/O callbacks：没有回调队列")]),t._v(" "),s("li",[t._v("poll：执行 I/O 操作，由于读取文件要耗费 95ms 的时间，这时它的任务队列为空，poll 将会阻塞在这里循环相应的回调函数。大约在 95ms 时相应的文件读取 I/O 操作执行完毕，对应的回调函数又耗费了 10ms。这时 poll queue 为空，此时 poll 会检查有没有到达阈值到期的 timer。发现存在一个已经超时近 5ms 的定时器")]),t._v(" "),s("li",[t._v("timers：回到 timers 阶段执行回调函数，打 log")])]),t._v(" "),s("p",[s("strong",[t._v("优先级："),s("code",[t._v("nextTick")]),t._v(" > "),s("code",[t._v("microtask")]),t._v(" | "),s("code",[t._v("setTimeout/setInterval")]),t._v(" > "),s("code",[t._v("setImmediate")])])]),t._v(" "),s("p",[t._v("上面介绍的都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列")]),t._v(" "),s("h2",{attrs:{id:"process-nexttick"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#process-nexttick"}},[t._v("#")]),t._v(" process.nextTick()")]),t._v(" "),s("p",[t._v("process.nextTick() 不是 Node 的 EL 中的一部分（虽然它也是异步 API），它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会"),s("strong",[t._v("清空队列中的所有回调函数")]),t._v("，并且优先于其他 microtask 执行。")]),t._v(" "),s("p",[t._v("资料：")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://javascript.ruanyifeng.com/nodejs/basic.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰 NODE"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=n.exports}}]);