<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Scope 和 Digest | 朝花夕拾</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="朝花夕拾技术空间">
    <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1, minimum-scale=1">
    <meta name="theme-color" content="#000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.d20caed7.css" as="style"><link rel="preload" href="/assets/js/app.12d26605.js" as="script"><link rel="preload" href="/assets/js/53.72aa59c3.js" as="script"><link rel="preload" href="/assets/js/2.e0269be8.js" as="script"><link rel="preload" href="/assets/js/1.c44a8a87.js" as="script"><link rel="preload" href="/assets/js/56.9d7794d3.js" as="script"><link rel="prefetch" href="/assets/js/100.bbb97386.js"><link rel="prefetch" href="/assets/js/101.8d859522.js"><link rel="prefetch" href="/assets/js/102.5ffd11db.js"><link rel="prefetch" href="/assets/js/103.911149a8.js"><link rel="prefetch" href="/assets/js/104.993fc457.js"><link rel="prefetch" href="/assets/js/105.bf452852.js"><link rel="prefetch" href="/assets/js/106.91365580.js"><link rel="prefetch" href="/assets/js/107.2eb027fb.js"><link rel="prefetch" href="/assets/js/108.b74f3ec8.js"><link rel="prefetch" href="/assets/js/109.0b38b68e.js"><link rel="prefetch" href="/assets/js/11.11a65ec8.js"><link rel="prefetch" href="/assets/js/110.b717b081.js"><link rel="prefetch" href="/assets/js/111.04b2f7d4.js"><link rel="prefetch" href="/assets/js/112.765b7740.js"><link rel="prefetch" href="/assets/js/113.61c3db26.js"><link rel="prefetch" href="/assets/js/114.c78dc659.js"><link rel="prefetch" href="/assets/js/115.fed4a5ff.js"><link rel="prefetch" href="/assets/js/116.9ce9905c.js"><link rel="prefetch" href="/assets/js/117.d74f2050.js"><link rel="prefetch" href="/assets/js/118.72a9294b.js"><link rel="prefetch" href="/assets/js/119.07a1d7ce.js"><link rel="prefetch" href="/assets/js/12.d44923b8.js"><link rel="prefetch" href="/assets/js/120.1c94762c.js"><link rel="prefetch" href="/assets/js/121.c75b3595.js"><link rel="prefetch" href="/assets/js/122.0495931f.js"><link rel="prefetch" href="/assets/js/123.40c44730.js"><link rel="prefetch" href="/assets/js/124.9497df2c.js"><link rel="prefetch" href="/assets/js/125.93c8044c.js"><link rel="prefetch" href="/assets/js/126.9ed9012c.js"><link rel="prefetch" href="/assets/js/127.4f135547.js"><link rel="prefetch" href="/assets/js/128.5f8bb42e.js"><link rel="prefetch" href="/assets/js/129.ae5036f3.js"><link rel="prefetch" href="/assets/js/13.f6bfbf5f.js"><link rel="prefetch" href="/assets/js/130.7cc88dec.js"><link rel="prefetch" href="/assets/js/131.8ceb7784.js"><link rel="prefetch" href="/assets/js/132.19085dca.js"><link rel="prefetch" href="/assets/js/133.456a4af2.js"><link rel="prefetch" href="/assets/js/134.f9a0568c.js"><link rel="prefetch" href="/assets/js/135.5c264cf3.js"><link rel="prefetch" href="/assets/js/136.bb073294.js"><link rel="prefetch" href="/assets/js/137.924277b7.js"><link rel="prefetch" href="/assets/js/138.2da39e10.js"><link rel="prefetch" href="/assets/js/139.fdf1661c.js"><link rel="prefetch" href="/assets/js/14.39120ea6.js"><link rel="prefetch" href="/assets/js/140.fe69773f.js"><link rel="prefetch" href="/assets/js/141.a02bc565.js"><link rel="prefetch" href="/assets/js/142.cec44adc.js"><link rel="prefetch" href="/assets/js/143.b5dddf7a.js"><link rel="prefetch" href="/assets/js/144.1a8d7b23.js"><link rel="prefetch" href="/assets/js/145.bd1b4c09.js"><link rel="prefetch" href="/assets/js/146.fbab1e9f.js"><link rel="prefetch" href="/assets/js/147.1bc36e45.js"><link rel="prefetch" href="/assets/js/148.775a0a0d.js"><link rel="prefetch" href="/assets/js/149.2934eb97.js"><link rel="prefetch" href="/assets/js/15.aafd58e3.js"><link rel="prefetch" href="/assets/js/150.61a22ce9.js"><link rel="prefetch" href="/assets/js/151.a2ecf5f4.js"><link rel="prefetch" href="/assets/js/152.a0f1e57b.js"><link rel="prefetch" href="/assets/js/153.903a2058.js"><link rel="prefetch" href="/assets/js/154.3b21dcea.js"><link rel="prefetch" href="/assets/js/155.04f1be1b.js"><link rel="prefetch" href="/assets/js/156.dfa97974.js"><link rel="prefetch" href="/assets/js/157.a252d5ec.js"><link rel="prefetch" href="/assets/js/158.ead31c62.js"><link rel="prefetch" href="/assets/js/159.cdd050a6.js"><link rel="prefetch" href="/assets/js/16.7cdfdee3.js"><link rel="prefetch" href="/assets/js/160.ca990cfa.js"><link rel="prefetch" href="/assets/js/161.fea4d060.js"><link rel="prefetch" href="/assets/js/162.8419b860.js"><link rel="prefetch" href="/assets/js/163.afee0e34.js"><link rel="prefetch" href="/assets/js/164.b07054b0.js"><link rel="prefetch" href="/assets/js/165.36a0886a.js"><link rel="prefetch" href="/assets/js/166.e83c26e4.js"><link rel="prefetch" href="/assets/js/167.6d4b68a7.js"><link rel="prefetch" href="/assets/js/168.97f4b7ac.js"><link rel="prefetch" href="/assets/js/169.00da5938.js"><link rel="prefetch" href="/assets/js/17.2f9fa8b1.js"><link rel="prefetch" href="/assets/js/170.8c772391.js"><link rel="prefetch" href="/assets/js/171.a62414d3.js"><link rel="prefetch" href="/assets/js/172.d6c87859.js"><link rel="prefetch" href="/assets/js/173.9b3bb810.js"><link rel="prefetch" href="/assets/js/174.6e5fc3aa.js"><link rel="prefetch" href="/assets/js/175.091b5977.js"><link rel="prefetch" href="/assets/js/176.64327ec7.js"><link rel="prefetch" href="/assets/js/177.68cf7cfa.js"><link rel="prefetch" href="/assets/js/178.027050bd.js"><link rel="prefetch" href="/assets/js/179.c89438a5.js"><link rel="prefetch" href="/assets/js/18.448dcd23.js"><link rel="prefetch" href="/assets/js/180.4dbc50dc.js"><link rel="prefetch" href="/assets/js/181.3051e1ed.js"><link rel="prefetch" href="/assets/js/182.87012ac0.js"><link rel="prefetch" href="/assets/js/183.cb1ef1dd.js"><link rel="prefetch" href="/assets/js/184.51f4a82a.js"><link rel="prefetch" href="/assets/js/185.48122045.js"><link rel="prefetch" href="/assets/js/186.a41b66e8.js"><link rel="prefetch" href="/assets/js/187.4762090e.js"><link rel="prefetch" href="/assets/js/188.77c7c50e.js"><link rel="prefetch" href="/assets/js/189.0897ec6a.js"><link rel="prefetch" href="/assets/js/19.08e227f3.js"><link rel="prefetch" href="/assets/js/190.54d5c2e5.js"><link rel="prefetch" href="/assets/js/191.0fbc3be9.js"><link rel="prefetch" href="/assets/js/192.7b371d27.js"><link rel="prefetch" href="/assets/js/193.93e484cb.js"><link rel="prefetch" href="/assets/js/194.51e221f8.js"><link rel="prefetch" href="/assets/js/195.3c63967b.js"><link rel="prefetch" href="/assets/js/196.23fb0b6d.js"><link rel="prefetch" href="/assets/js/197.4ef07932.js"><link rel="prefetch" href="/assets/js/198.831d0422.js"><link rel="prefetch" href="/assets/js/199.4ec8aafb.js"><link rel="prefetch" href="/assets/js/20.605bdcf3.js"><link rel="prefetch" href="/assets/js/200.5440a794.js"><link rel="prefetch" href="/assets/js/201.f0bd0bdc.js"><link rel="prefetch" href="/assets/js/202.1f354f84.js"><link rel="prefetch" href="/assets/js/203.37e27f85.js"><link rel="prefetch" href="/assets/js/204.4f344138.js"><link rel="prefetch" href="/assets/js/205.274c9ffe.js"><link rel="prefetch" href="/assets/js/206.296efaa9.js"><link rel="prefetch" href="/assets/js/207.8d8416a8.js"><link rel="prefetch" href="/assets/js/208.af5e9d17.js"><link rel="prefetch" href="/assets/js/209.1bb65632.js"><link rel="prefetch" href="/assets/js/21.96552e03.js"><link rel="prefetch" href="/assets/js/210.5b35bb3d.js"><link rel="prefetch" href="/assets/js/211.04018ccd.js"><link rel="prefetch" href="/assets/js/212.9f58279b.js"><link rel="prefetch" href="/assets/js/213.2129479e.js"><link rel="prefetch" href="/assets/js/214.14cca2bc.js"><link rel="prefetch" href="/assets/js/215.b2e14cd6.js"><link rel="prefetch" href="/assets/js/216.ccd4a0de.js"><link rel="prefetch" href="/assets/js/217.3308608b.js"><link rel="prefetch" href="/assets/js/218.3b538e68.js"><link rel="prefetch" href="/assets/js/219.eace41b3.js"><link rel="prefetch" href="/assets/js/22.e3c0da27.js"><link rel="prefetch" href="/assets/js/220.25d4452d.js"><link rel="prefetch" href="/assets/js/23.dde885f4.js"><link rel="prefetch" href="/assets/js/24.c2926c0e.js"><link rel="prefetch" href="/assets/js/25.4a525b44.js"><link rel="prefetch" href="/assets/js/26.98ecb5dd.js"><link rel="prefetch" href="/assets/js/27.fc414320.js"><link rel="prefetch" href="/assets/js/28.b3f0796c.js"><link rel="prefetch" href="/assets/js/29.bb74639a.js"><link rel="prefetch" href="/assets/js/3.be66794d.js"><link rel="prefetch" href="/assets/js/30.ffb8250c.js"><link rel="prefetch" href="/assets/js/31.ed5d02bd.js"><link rel="prefetch" href="/assets/js/32.87ab1d4c.js"><link rel="prefetch" href="/assets/js/33.8982be72.js"><link rel="prefetch" href="/assets/js/34.880389f8.js"><link rel="prefetch" href="/assets/js/35.d32837ce.js"><link rel="prefetch" href="/assets/js/36.ea0972c9.js"><link rel="prefetch" href="/assets/js/37.6f366584.js"><link rel="prefetch" href="/assets/js/38.269c66df.js"><link rel="prefetch" href="/assets/js/39.22eb318f.js"><link rel="prefetch" href="/assets/js/4.8bc67bf2.js"><link rel="prefetch" href="/assets/js/40.5d05faee.js"><link rel="prefetch" href="/assets/js/41.e5635104.js"><link rel="prefetch" href="/assets/js/42.9051d65f.js"><link rel="prefetch" href="/assets/js/43.80840d11.js"><link rel="prefetch" href="/assets/js/44.b512911d.js"><link rel="prefetch" href="/assets/js/45.fa265768.js"><link rel="prefetch" href="/assets/js/46.f6c8601c.js"><link rel="prefetch" href="/assets/js/47.e9a5da56.js"><link rel="prefetch" href="/assets/js/48.3bbe79f3.js"><link rel="prefetch" href="/assets/js/49.9c517799.js"><link rel="prefetch" href="/assets/js/5.615387f8.js"><link rel="prefetch" href="/assets/js/50.d3902346.js"><link rel="prefetch" href="/assets/js/51.d8faba76.js"><link rel="prefetch" href="/assets/js/52.d63ee36f.js"><link rel="prefetch" href="/assets/js/54.59c5fdfa.js"><link rel="prefetch" href="/assets/js/55.a09411af.js"><link rel="prefetch" href="/assets/js/57.1d6df513.js"><link rel="prefetch" href="/assets/js/58.fbfd2f82.js"><link rel="prefetch" href="/assets/js/59.228069e9.js"><link rel="prefetch" href="/assets/js/6.87a783be.js"><link rel="prefetch" href="/assets/js/60.7c835705.js"><link rel="prefetch" href="/assets/js/61.894daacb.js"><link rel="prefetch" href="/assets/js/62.48345531.js"><link rel="prefetch" href="/assets/js/63.68273146.js"><link rel="prefetch" href="/assets/js/64.9403a931.js"><link rel="prefetch" href="/assets/js/65.f1c28c07.js"><link rel="prefetch" href="/assets/js/66.8ca0abdd.js"><link rel="prefetch" href="/assets/js/67.ae78e826.js"><link rel="prefetch" href="/assets/js/68.6a8e900d.js"><link rel="prefetch" href="/assets/js/69.1b948fa8.js"><link rel="prefetch" href="/assets/js/7.a5cf5266.js"><link rel="prefetch" href="/assets/js/70.2c05a67c.js"><link rel="prefetch" href="/assets/js/71.12aaf3ee.js"><link rel="prefetch" href="/assets/js/72.531c3a30.js"><link rel="prefetch" href="/assets/js/73.40d4efc6.js"><link rel="prefetch" href="/assets/js/74.c7dac0ed.js"><link rel="prefetch" href="/assets/js/75.bb3d9a4f.js"><link rel="prefetch" href="/assets/js/76.4c0d9b75.js"><link rel="prefetch" href="/assets/js/77.15faeebd.js"><link rel="prefetch" href="/assets/js/78.5a52047c.js"><link rel="prefetch" href="/assets/js/79.3a31f293.js"><link rel="prefetch" href="/assets/js/80.c3006a35.js"><link rel="prefetch" href="/assets/js/81.bc5af2b4.js"><link rel="prefetch" href="/assets/js/82.1a58c9a7.js"><link rel="prefetch" href="/assets/js/83.4470592c.js"><link rel="prefetch" href="/assets/js/84.19e940d9.js"><link rel="prefetch" href="/assets/js/85.242210f5.js"><link rel="prefetch" href="/assets/js/86.e919b15e.js"><link rel="prefetch" href="/assets/js/87.71c4f647.js"><link rel="prefetch" href="/assets/js/88.5ddc7083.js"><link rel="prefetch" href="/assets/js/89.857678ef.js"><link rel="prefetch" href="/assets/js/90.357bdad0.js"><link rel="prefetch" href="/assets/js/91.72beef29.js"><link rel="prefetch" href="/assets/js/92.c2095f6e.js"><link rel="prefetch" href="/assets/js/93.71ee9727.js"><link rel="prefetch" href="/assets/js/94.98caab4d.js"><link rel="prefetch" href="/assets/js/95.ff59f519.js"><link rel="prefetch" href="/assets/js/96.824a93c9.js"><link rel="prefetch" href="/assets/js/97.2aea7b50.js"><link rel="prefetch" href="/assets/js/98.d3ec5dbd.js"><link rel="prefetch" href="/assets/js/99.3562efa4.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.f862dbd1.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.ba24f44a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d20caed7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">朝花夕拾</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Introduction.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/FrontEnd/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://vue3.tanyp.xyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue3
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/React/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link">
  Vue2
</a></li><li class="dropdown-item"><!----> <a href="/AngularJS/" class="nav-link router-link-active">
  AngularJS
</a></li></ul></div></div><div class="nav-item"><a href="/JsFrame/" class="nav-link">
  技术方案
</a></div><div class="nav-item"><a href="/FrontEndTool/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/NodeJS/" class="nav-link">
  NodeJS
</a></div><div class="nav-item"><a href="/TS/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/Java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  Notes
</a></div><div class="nav-item"><a href="/Reading/" class="nav-link">
  Reading
</a></div><div class="nav-item"><a href="/DSA/" class="nav-link">
  数据结构与算法
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Introduction.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/FrontEnd/" class="nav-link">
  前端基础
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://vue3.tanyp.xyz" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue3
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/React/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link">
  Vue2
</a></li><li class="dropdown-item"><!----> <a href="/AngularJS/" class="nav-link router-link-active">
  AngularJS
</a></li></ul></div></div><div class="nav-item"><a href="/JsFrame/" class="nav-link">
  技术方案
</a></div><div class="nav-item"><a href="/FrontEndTool/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/NodeJS/" class="nav-link">
  NodeJS
</a></div><div class="nav-item"><a href="/TS/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/Java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  Notes
</a></div><div class="nav-item"><a href="/Reading/" class="nav-link">
  Reading
</a></div><div class="nav-item"><a href="/DSA/" class="nav-link">
  数据结构与算法
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/AngularJS/Scope和Digest.html" class="active sidebar-link">Scope 和 Digest</a></li><li><a href="/AngularJS/DI.html" class="sidebar-link">DI</a></li><li><a href="/AngularJS/指令.html" class="sidebar-link">ngModel 指令</a></li><li><a href="/AngularJS/parse和eval.html" class="sidebar-link">$parse和$eval的用法</a></li><li><a href="/AngularJS/笔记.html" class="sidebar-link">笔记</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="构建自己的-angularjs-第一部分-scope-和-digest"><a href="#构建自己的-angularjs-第一部分-scope-和-digest" class="header-anchor">#</a> 构建自己的 AngularJS，第一部分：Scope 和 Digest</h2> <p>原文链接：http://teropa.info/blog/2013/11/03/make-your-own-angular-part-1-scopes-and-digest.html</p> <p>Angular 是一个成熟和强大的 JavaScript 框架。它也是一个比较庞大的框架，在熟练掌握之前，需要领会它提出的很多新概念。很多 Web 开发人员涌向 Angular，有不少人面临同样的障碍。Digest 到底是怎么做的？定义一个指令（directive）有哪些不同的方法？Service 和 provider 有什么区别？</p> <p>Angular 的文档挺不错的，第三方的资源也越来越丰富，想要学习一门新的技术，没什么方法比把它拆开研究其运作机制更好。</p> <p>在这个系列的文章中，我将从无到有构建 AngularJS 的一个实现。随着逐步深入的讲解，读者将能对 Angular 的运作机制有一个深入的认识。</p> <p>在第一部分中，读者将看到 Angular 的作用域是如何运作的，还有比如 $eval, $digest, $apply 这些东西怎么实现。Angular 的脏检查逻辑看上去有些不可思议，但你将看到实际并非如此。</p> <h2 id="基础知识"><a href="#基础知识" class="header-anchor">#</a> 基础知识</h2> <p>在 Github 上，可以看到这个项目的全部源码。相比只复制一份下来，我更建议读者从无到有构建自己的实现，从不同角度探索代码的每个步骤。在本文中，我嵌入了 JSBin 的一些代码，可以直接在文章中进行一些互动。（译者注：因为我在 github 上翻译，没法集成 JSBin 了，只能给链接……）</p> <p>我们将使用 Lo-Dash 库来处理一些在数组和对象上的底层操作。Angular 自身并未使用 Lo-Dash，但是从我们的目的看，要尽量无视这些不太相关的比较底层的事情。当读者在代码中看到下划线（_）的时候，那就是在调用 Lo-Dash 的功能。</p> <p>我们还将使用 console.assert 函数做一些特别的测试。这个函数应该适用于所有现代 JavaScript 环境。</p> <p>下面是使用 Lo-Dash 和 assert 函数的示例：</p> <p>http://jsbin.com/UGOVUk/4/embed?js,console</p> <h2 id="scope-对象"><a href="#scope-对象" class="header-anchor">#</a> Scope 对象</h2> <p>Angular 的 Scope 对象是 POJO（简单的 JavaScript 对象），在它们上面，可以像对其他对象一样添加属性。Scope 对象是用构造函数创建的，我们来写个最简单的版本：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>现在我们就可以使用 new 操作符来创建一个 Scope 对象了。我们也可以在它上面附加一些属性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> aScope <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
aScope<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">&quot;Jane&quot;</span><span class="token punctuation">;</span>
aScope<span class="token punctuation">.</span>lastName <span class="token operator">=</span> <span class="token string">&quot;Smith&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>这些属性没什么特别的。不需要调用特别的设置器（setter），赋值的时候也没什么限制。相反，在两个特别的函数：$watch 和 $digest 之中发生了一些奇妙的事情。</p> <h2 id="监控对象属性-watch-和-digest"><a href="#监控对象属性-watch-和-digest" class="header-anchor">#</a> 监控对象属性：$watch 和 $digest</h2> <p>$watch 和 $digest 是相辅相成的。两者一起，构成了 Angular 作用域的核心：数据变化的响应。</p> <p>使用 $watch，可以在 Scope 上添加一个监听器。当 Scope 上发生变更时，监听器会收到提示。给 $watch 指定如下两个函数，就可以创建一个监听器：</p> <ul><li>一个监控函数，用于指定所关注的那部分数据。</li> <li>一个监听函数，用于在数据变更的时候接受提示。</li></ul> <blockquote><p>作为一名 Angular 用户，一般来说，是监控一个表达式，而不是使用监控函数。监控表达式是一个字符串，比如说“user.firstName”，通常在数据绑定，指令的属性，或者 JavaScript 代码中指定，它被 Angular 解析和编译成一个监控函数。在这篇文章的后面部分我们会探讨这是如何做的。在这篇文章中，我们将使用稍微低级的方法直接提供监控功能。</p></blockquote> <p>为了实现 $watch，我们需要存储注册过的所有监听器。我们在 Scope 构造函数上添加一个数组：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 Angular 框架中，双美元符前缀 $$ 表示这个变量被当作私有的来考虑，不应当在外部代码中调用。</p> <p>现在我们可以定义 $watch 方法了。它接受两个函数作参数，把它们存储在 $$watchers 数组中。我们需要在每个 Scope 实例上存储这些函数，所以要把它放在 Scope 的原型上：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watchFn<span class="token punctuation">,</span> listenerFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">watchFn</span><span class="token operator">:</span> watchFn<span class="token punctuation">,</span>
    <span class="token literal-property property">listenerFn</span><span class="token operator">:</span> listenerFn<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>另外一面就是 $digest 函数。它执行了所有在作用域上注册过的监听器。我们来实现一个它的简化版，遍历所有监听器，调用它们的监听函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$digest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    watch<span class="token punctuation">.</span><span class="token function">listenerFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们可以添加监听器，然后运行 $digest 了，这将会调用监听函数：</p> <p>http://jsbin.com/oMaQoxa/2/embed?js,console</p> <p>这些本身没什么大用，我们要的是能检测由监控函数指定的值是否确实变更了，然后调用监听函数。</p> <h2 id="脏值检测"><a href="#脏值检测" class="header-anchor">#</a> 脏值检测</h2> <p>如同上文所述，监听器的监听函数应当返回我们所关注的那部分数据的变化，通常，这部分数据就存在于作用域中。为了使得访问作用域更便利，在调用监控函数的时候，使用当前作用域作为实参。一个关注作用域上 fiestName 属性的监听器像这个样子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">scope</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> scope<span class="token punctuation">.</span>firstName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是监控函数的一般形式：从作用域获取一些值，然后返回。</p> <p>$digest 函数的作用是调用这个监控函数，并且比较它返回的值和上一次返回值的差异。如果不相同，监听器就是脏的，它的监听函数就应当被调用。</p> <p>想要这么做，$digest 需要记住每个监控函数上次返回的值。既然我们现在已经为每个监听器创建过一个对象，只要把上一次的值存在这上面就行了。下面是检测每个监控函数值变更的 $digest 新实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$digest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  _<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> newValue <span class="token operator">=</span> watch<span class="token punctuation">.</span><span class="token function">watchFn</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> oldValue <span class="token operator">=</span> watch<span class="token punctuation">.</span>last<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!==</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      watch<span class="token punctuation">.</span><span class="token function">listenerFn</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    watch<span class="token punctuation">.</span>last <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>对每个监听器，我们调用监控函数，把作用域自身当作实参传递进去，然后比较这个返回值和上次返回值，如果不同，就调用监听函数。方便起见，我们把新旧值和作用域都当作参数传递给监听函数。最终，我们把监听器的 last 属性设置成新返回的值，下一次可以用它来作比较。</p> <p>有了这个实现之后，我们就可以看到在 $digest 调用的时候，监听函数是怎么执行的：</p> <p>http://jsbin.com/OsITIZu/3/embed?js,console</p> <p>我们已经实现了 Angular 作用域的本质：添加监听器，在 digest 里运行它们。</p> <p>也已经可以看到几个关于 Angular 作用域的重要性能特性：</p> <ul><li><p>在作用域上添加数据本身并不会有性能折扣。如果没有监听器在监控某个属性，它在不在作用域上都无所谓。Angular 并不会遍历作用域的属性，它遍历的是监听器。</p></li> <li><p>$digest 里会调用每个监控函数，因此，最好关注监听器的数量，还有每个独立的监控函数或者表达式的性能。</p></li></ul> <h2 id="在-digest-的时候获得提示"><a href="#在-digest-的时候获得提示" class="header-anchor">#</a> 在 Digest 的时候获得提示</h2> <p>如果你想在每次 Angular 的作用域被 digest 的时候得到通知，可以利用每次 digest 的时候挨个执行监听器这个事情，只要注册一个没有监听函数的监听器就可以了。</p> <p>想要支持这个用例，我们需要在 $watch 里面检测是否监控函数被省略了，如果是这样，用个空函数来代替它：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watchFn<span class="token punctuation">,</span> listenerFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">watchFn</span><span class="token operator">:</span> watchFn<span class="token punctuation">,</span>
    <span class="token literal-property property">listenerFn</span><span class="token operator">:</span> listenerFn <span class="token operator">||</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>如果用了这个模式，需要记住，即使没有 listenerFn，Angular 也会寻找 watchFn 的返回值。如果返回了一个值，这个值会提交给脏检查。想要采用这个用法又想避免多余的事情，只要监控函数不返回任何值就行了。在这个例子里，监听器的值始终会是未定义的。</p> <p>http://jsbin.com/OsITIZu/4/embed?js,console</p> <p>这个实现的核心就这样，但是离最终的还是差太远了。比如说有个很典型的场景我们不能支持：监听函数自身也修改作用域上的属性。如果这个发生了，另外有个监听器在监控被修改的属性，有可能在同一个 digest 里面检测不到这个变动：</p> <p>http://jsbin.com/eTIpUyE/2/embed?js,console</p> <p>我们来修复这个问题。</p> <h2 id="当数据脏的时候持续-digest"><a href="#当数据脏的时候持续-digest" class="header-anchor">#</a> 当数据脏的时候持续 Digest</h2> <p>我们需要改变一下 digest，让它持续遍历所有监听器，直到监控的值停止变更。</p> <p>首先，我们把现在的 $digest 函数改名为 $$digestOnce，它把所有的监听器运行一次，返回一个布尔值，表示是否还有变更了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$$digestOnce</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  _<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> newValue <span class="token operator">=</span> watch<span class="token punctuation">.</span><span class="token function">watchFn</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> oldValue <span class="token operator">=</span> watch<span class="token punctuation">.</span>last<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!==</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      watch<span class="token punctuation">.</span><span class="token function">listenerFn</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">;</span>
      dirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    watch<span class="token punctuation">.</span>last <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> dirty<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>然后，我们重新定义 $digest，它作为一个“外层循环”来运行，当有变更发生的时候，调用 $$digestOnce：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$digest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    dirty <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$$digestOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>$digest 现在至少运行每个监听器一次了。如果第一次运行完，有监控值发生变更了，标记为 dirty，所有监听器再运行第二次。这会一直运行，直到所有监控的值都不再变化，整个局面稳定下来了。</p> <blockquote><p>Angular 作用域里并不是真的有个函数叫做 $$digestOnce，相反，digest 循环都是包含在 $digest 里的。我们的目标更多是清晰度而不是性能，所以把内层循环封装成了一个函数。</p></blockquote> <p>下面是新的实现：</p> <p>http://jsbin.com/Imoyosa/3/embed?js,console</p> <p>我们现在可以对 Angular 的监听器有另外一个重要认识：它们可能在单次 digest 里面被执行多次。这也就是为什么人们经常说，监听器应当是幂等的：一个监听器应当没有边界效应，或者边界效应只应当发生有限次。比如说，假设一个监控函数触发了一个 Ajax 请求，无法确定你的应用程序发了多少个请求。</p> <p>在我们现在的实现中，有一个明显的遗漏：如果两个监听器互相监控了对方产生的变更，会怎样？也就是说，如果状态始终不会稳定？这种情况展示在下面的代码里。在这个例子里，$digest 调用被注释掉了，把注释去掉看看发生什么情况：</p> <p>http://jsbin.com/eKEvOYa/3/embed?js,console</p> <p>JSBin 执行了一段时间之后就停止了（在我机器上大概跑了 100,000 次左右）。如果你在别的东西比如 Node.js 里跑，它会一直运行下去。</p> <h2 id="放弃不稳定的-digest"><a href="#放弃不稳定的-digest" class="header-anchor">#</a> 放弃不稳定的 digest</h2> <p>我们要做的事情是，把 digest 的运行控制在一个可接受的迭代数量内。如果这么多次之后，作用域还在变更，就勇敢放手，宣布它永远不会稳定。在这个点上，我们会抛出一个异常，因为不管作用域的状态变成怎样，它都不太可能是用户想要的结果。</p> <p>迭代的最大值称为 TTL（short for Time To Live）。这个值默认是 10，可能有点小（我们刚运行了这个 digest 100,000 次！），但是记住这是一个性能敏感的地方，因为 digest 经常被执行，而且每个 digest 运行了所有的监听器。用户也不太可能创建 10 个以上链状的监听器。</p> <blockquote><p>事实上，Angular 里面的 TTL 是可以调整的。我们将在后续文章讨论 provider 和依赖注入的时候再回顾这个话题。</p></blockquote> <p>我们继续，给外层 digest 循环添加一个循环计数器。如果达到了 TTL，就抛出异常：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$digest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ttl <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    dirty <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$$digestOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ttl<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token string">&quot;10 digest iterations reached&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>下面是更新过的版本，可以让我们循环引用的监控例子抛出异常：</p> <p>http://jsbin.com/uNapUWe/2/embed?js,console</p> <p>这些应当已经把 digest 的事情说清楚了。</p> <p>现在，我们把注意力转到如何检测变更上吧。</p> <h2 id="基于值的脏检查"><a href="#基于值的脏检查" class="header-anchor">#</a> 基于值的脏检查</h2> <p>我们曾经使用严格等于操作符 (===) 来比较新旧值，在绝大多数情况下，它是不错的，比如所有的基本类型（数字，字符串等等），也可以检测一个对象或者数组是否变成新的了，但 Angular 还有一种办法来检测变更，用于检测当对象或者数组内部产生变更的时候。那就是：可以监控值的变更，而不是引用。</p> <p>这类脏检查需要给 $watch 函数传入第三个布尔类型的可选参数当标志来开启。当这个标志为真的时候，基于值的检查开启。我们来重新定义 $watch，接受这个参数，并且把它存在监听器里：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watchFn<span class="token punctuation">,</span> listenerFn<span class="token punctuation">,</span> valueEq</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">watchFn</span><span class="token operator">:</span> watchFn<span class="token punctuation">,</span>
    <span class="token literal-property property">listenerFn</span><span class="token operator">:</span> listenerFn<span class="token punctuation">,</span>
    <span class="token literal-property property">valueEq</span><span class="token operator">:</span> <span class="token operator">!</span><span class="token operator">!</span>valueEq<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们所做的一切是把这个标志加在监听器上，通过两次取反，强制转换为布尔类型。当用户调用 $watch，没传入第三个参数的时候，valueEq 会是未定义的，在监听器对象里就变成了 false。</p> <p>基于值的脏检查意味着如果新旧值是对象或者数组，我们必须遍历其中包含的所有内容。如果它们之间有任何差异，监听器就脏了。如果该值包含嵌套的对象或者数组，它也会递归地按值比较。</p> <p>Angular 内置了自己的相等检测函数，但是我们会用 Lo-Dash 提供的那个。让我们定义一个新函数，取两个值和一个布尔标志，并比较相应的值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$$areEqual</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> valueEq</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>valueEq<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">isEqual</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> newValue <span class="token operator">===</span> oldValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>为了提示值的变化，我们也需要改变之前在每个监听器上存储旧值的方式。只存储当前值的引用是不够的，因为在这个值内部发生的变更也会生效到它的引用上，$$areEqual 方法比较同一个值的两个引用始终为真，监控不到变化，因此，我们需要建立当前值的深拷贝，并且把它们储存起来。</p> <p>就像相等检测一样，Angular 也内置了自己的深拷贝函数，但我们还是用 Lo-Dash 提供的。我们修改一下 $digestOnce，在内部使用新的 $$areEqual 函数，如果需要的话，也复制最后一次的引用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$$digestOnce</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  _<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> newValue <span class="token operator">=</span> watch<span class="token punctuation">.</span><span class="token function">watchFn</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> oldValue <span class="token operator">=</span> watch<span class="token punctuation">.</span>last<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">$$areEqual</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> watch<span class="token punctuation">.</span>valueEq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      watch<span class="token punctuation">.</span><span class="token function">listenerFn</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">;</span>
      dirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    watch<span class="token punctuation">.</span>last <span class="token operator">=</span> watch<span class="token punctuation">.</span>valueEq <span class="token operator">?</span> _<span class="token punctuation">.</span><span class="token function">cloneDeep</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token operator">:</span> newValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> dirty<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们可以看到两种脏检测方式的差异：</p> <p>http://jsbin.com/ARiWENO/3/embed?js,console</p> <p>相比检查引用，检查值的方式显然是一个更为复杂的操作。遍历嵌套的数据结构很花时间，保持深拷贝的数据也占用不少内存。这就是 Angular 默认不使用基于值的脏检测的原因，用户需要显式设置这个标记去打开它。</p> <blockquote><p>Angular 也提供了第三种脏检测的方法：集合监控。就像基于值的检测，也能提示对象和数组中的变更。但不同于基于值的检测方式，它做的是一个比较浅的检测，并不递归进入到深层去，所以它比基于值的检测效率更高。集合检测是通过“$watchCollection”函数来使用的，在这个系列的后续部分，我们会来看看它是如何实现的。</p></blockquote> <p>在我们完成值的比对之前，还有些 JavaScript 怪事要处理一下。</p> <h2 id="非数字-nan"><a href="#非数字-nan" class="header-anchor">#</a> 非数字（NaN）</h2> <p>在 JavaScript 里，NaN（Not-a-Number）并不等于自身，这个听起来有点怪，但确实就这样。如果我们在脏检测函数里不显式处理 NaN，一个值为 NaN 的监听器会一直是脏的。</p> <p>对于基于值的脏检测来说，这个事情已经被 Lo-Dash 的 isEqual 函数处理掉了。对于基于引用的脏检测来说，我们需要自己处理。来修改一下 $$areEqual 函数的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$$areEqual</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> valueEq</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>valueEq<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">isEqual</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      newValue <span class="token operator">===</span> oldValue <span class="token operator">||</span>
      <span class="token punctuation">(</span><span class="token keyword">typeof</span> newValue <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span> <span class="token operator">&amp;&amp;</span>
        <span class="token keyword">typeof</span> oldValue <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">isNaN</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">isNaN</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>现在有 NaN 的监听器也正常了：</p> <p>http://jsbin.com/ijINaRA/2/embed?js,console</p> <p>基于值的检测实现好了，现在我们该把注意力集中到应用程序代码如何跟作用域打交道上了。</p> <h2 id="eval-在作用域的上下文上执行代码"><a href="#eval-在作用域的上下文上执行代码" class="header-anchor">#</a> $eval - 在作用域的上下文上执行代码</h2> <p>在 Angular 中，有几种方式可以在作用域的上下文上执行代码，最简单的一种就是 $eval。它使用一个函数作参数，所做的事情是立即执行这个传入的函数，并且把作用域自身当作参数传递给它，返回的是这个函数的返回值。$eval 也可以有第二个参数，它所做的仅仅是把这个参数传递给这个函数。</p> <p>$eval 的实现很简单：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$eval</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">expr<span class="token punctuation">,</span> locals</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">expr</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> locals<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>$eval 的使用一样很简单：</p> <p>http://jsbin.com/UzaWUC/1/embed?js,console</p> <p>那么，为什么要用这么一种明显很多余的方式去执行一个函数呢？有人觉得，有些代码是专门与作用域的内容打交道的，$eval 让这一切更加明显。$eval 也是构建 $apply 的一个部分，后面我们就来讲它。</p> <p>然后，可能 $eval 最有意思的用法是当我们不传入函数，而是表达式。就像 $watch 一样，可以给 $eval 一个字符串表达式，它会把这个表达式编译，然后在作用域的上下文中执行。我们将在这个系列的后面部分实现这些。</p> <h2 id="apply-集成外部代码与-digest-循环"><a href="#apply-集成外部代码与-digest-循环" class="header-anchor">#</a> $apply - 集成外部代码与 digest 循环</h2> <p>可能 Scope 上所有函数里最有名的就是 $apply 了。它被誉为将外部库集成到 Angular 的最标准的方式，这话有个不错的理由。</p> <p>$apply 使用函数作参数，它用 $eval 执行这个函数，然后通过 $digest 触发 digest 循环。下面是一个简单的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$apply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">expr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$eval</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>$digest 的调用放置于 finally 块中，以确保即使函数抛出异常，也会执行 digest。</p> <p>关于 $apply，大的想法是，我们可以执行一些与 Angular 无关的代码，这些代码也还是可以改变作用域上的东西，$apply 可以保证作用域上的监听器可以检测这些变更。当人们谈论使用 $apply 集成代码到“Angular 生命周期”的时候，他们指的就是这个事情，也没什么比这更重要的了。</p> <p>这里是 $apply 的实践：</p> <p>http://jsbin.com/UzaWUC/2/embed?js,console</p> <h2 id="延迟执行-evalasync"><a href="#延迟执行-evalasync" class="header-anchor">#</a> 延迟执行 - $evalAsync</h2> <p>在 JavaScript 中，经常会有把一段代码“延迟”执行的情况 - 把它的执行延迟到当前的执行上下文结束之后的未来某个时间点。最常见的方式就是调用 setTimeout() 函数，传递一个 0（或者非常小）作为延迟参数。</p> <p>这种模式也适用于 Angular 程序，但更推荐的方式是使用 $timeout 服务，并且使用 $apply 把要延迟执行的函数集成到 digest 生命周期。</p> <p>但在 Angular 中还有一种延迟代码的方式，那就是 Scope 上的 $evalAsync 函数。$evalAsync 接受一个函数，把它列入计划，在当前正持续的 digest 中或者下一次 digest 之前执行。举例来说，你可以在一个监听器的监听函数中延迟执行一些代码，即使它已经被延迟了，仍然会在现有的 digest 遍历中被执行。</p> <p>我们首先需要的是存储 $evalAsync 列入计划的任务，可以在 Scope 构造函数中初始化一个数组来做这事：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们再来定义 $evalAsync，它添加将在这个队列上执行的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$evalAsync</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">expr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">scope</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token literal-property property">expression</span><span class="token operator">:</span> expr <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们显式在放入队列的对象上设置当前作用域，是为了使用作用域的继承，在这个系列的下一篇文章中，我们会讨论这个。</p> <p>然后，我们在 $digest 中要做的第一件事就是从队列中取出每个东西，然后使用 $eval 来触发所有被延迟执行的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$digest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ttl <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> asyncTask <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$eval</span><span class="token punctuation">(</span>asyncTask<span class="token punctuation">.</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dirty <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$$digestOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ttl<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token string">&quot;10 digest iterations reached&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这个实现保证了：如果当作用域还是脏的，就想把一个函数延迟执行，那这个函数会在稍后执行，但还处于同一个 digest 中。</p> <p>下面是关于如何使用 $evalAsync 的一个示例：</p> <p>http://jsbin.com/ilepOwI/1/embed?js,console</p> <h2 id="作用域阶段"><a href="#作用域阶段" class="header-anchor">#</a> 作用域阶段</h2> <p>$evalAsync 做的另外一件事情是：如果现在没有其他的 $digest 在运行的话，把给定的 $digest 延迟执行。这意味着，无论什么时候调用 $evalAsync，可以确定要延迟执行的这个函数会“很快”被执行，而不是等到其他什么东西来触发一次 digest。</p> <p>需要有一种机制让 $evalAsync 来检测某个 $digest 是否已经在运行了，因为它不想影响到被列入计划将要执行的那个。为此，Angular 的作用域实现了一种叫做阶段（phase）的东西，它就是作用域上一个简单的字符串属性，存储了现在正在做的信息。</p> <p>在 Scope 的构造函数里，我们引入一个叫 $$phase 的字段，初始化为 null：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$phase <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，我们定义一些方法用于控制这个阶段变量：一个用于设置，一个用于清除，也加个额外的检测，以确保不会把已经激活状态的阶段再设置一次：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$beginPhase</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">phase</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$phase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$$phase <span class="token operator">+</span> <span class="token string">&quot; already in progress.&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$phase <span class="token operator">=</span> phase<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$clearPhase</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$phase <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在 $digest 方法里，我们来从外层循环设置阶段属性为“$digest”：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$digest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ttl <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$beginPhase</span><span class="token punctuation">(</span><span class="token string">&quot;$digest&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> asyncTask <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$eval</span><span class="token punctuation">(</span>asyncTask<span class="token punctuation">.</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dirty <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$$digestOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ttl<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$clearPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">throw</span> <span class="token string">&quot;10 digest iterations reached&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$clearPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们把 $apply 也修改一下，在它里面也设置个跟自己一样的阶段。在调试的时候，这个会有些用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$apply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">expr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$beginPhase</span><span class="token punctuation">(</span><span class="token string">&quot;$apply&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$eval</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$clearPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>最终，把对 $digest 的调度放进 $evalAsync。它会检测作用域上现有的阶段变量，如果没有（也没有已列入计划的异步任务），就把这个 digest 列入计划。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$evalAsync</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">expr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token punctuation">.</span>$$phase <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>self<span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        self<span class="token punctuation">.</span><span class="token function">$digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  self<span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">scope</span><span class="token operator">:</span> self<span class="token punctuation">,</span> <span class="token literal-property property">expression</span><span class="token operator">:</span> expr <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>有了这个实现之后，不管何时、何地，调用 $evalAsync，都可以确定有一个 digest 会在不远的将来发生。</p> <p>http://jsbin.com/iKeSaGi/1/embed?js,console</p> <h1 id="在-digest-之后执行代码-postdigest"><a href="#在-digest-之后执行代码-postdigest" class="header-anchor">#</a> 在 digest 之后执行代码 - $$postDigest</h1> <p>还有一种方式可以把代码附加到 digest 循环中，那就是把一个 $$postDigest 函数列入计划。</p> <p>在 Angular 中，函数名字前面有双美元符号表示它是一个内部的东西，不是应用开发人员应该用的。但它确实存在，所以我们也要把它实现出来。</p> <p>就像 $evalAsync 一样，$$postDigest 也能把一个函数列入计划，让它“以后”运行。具体来说，这个函数将在下一次 digest 完成之后运行。将一个 $$postDigest 函数列入计划不会导致一个 digest 也被延后，所以这个函数的执行会被推迟到直到某些其他原因引起一次 digest。顾名思义，$$postDigest 函数是在 digest 之后运行的，如果你在 $$digest 里面修改了作用域，需要手动调用 $digest 或者 $apply，以确保这些变更生效。</p> <p>首先，我们给 Scope 的构造函数加队列，这个队列给 $$postDigest 函数用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Scope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$postDigestQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$phase <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，我们把 $$postDigest 也加上去，它所做的就是把给定的函数加到队列里：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$$postDigest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$$postDigestQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>最终，在 $digest 里，当 digest 完成之后，就把队列里面的函数都执行掉。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$digest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ttl <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$beginPhase</span><span class="token punctuation">(</span><span class="token string">&quot;$digest&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> asyncTask <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$eval</span><span class="token punctuation">(</span>asyncTask<span class="token punctuation">.</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dirty <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$$digestOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ttl<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$clearPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">throw</span> <span class="token string">&quot;10 digest iterations reached&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$clearPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$postDigestQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$$postDigestQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>下面是关于如何使用 $$postDigest 函数的：</p> <p>http://jsbin.com/IMEhowO/1/embed?js,console</p> <h2 id="异常处理"><a href="#异常处理" class="header-anchor">#</a> 异常处理</h2> <p>现有对 Scope 的实现已经逐渐接近在 Angular 中实际的样子了，但还有些脆弱，因为我们迄今为止没有花精力在异常处理上。</p> <p>Angular 的作用域在遇到错误的时候是非常健壮的：当产生异常的时候，不管在监控函数中，在 $evalAsync 函数中，还是在 $$postDigest 函数中，都不会把 digest 终止掉。我们现在的实现里，在以上任何地方产生异常都会把整个 $digest 弄挂。</p> <p>我们可以很容易修复它，把上面三个调用包在 try...catch 中就好了。</p> <blockquote><p>Angular 实际上是把这些异常抛给了它的 $exceptionHandler 服务。既然我们现在还没有这东西，先扔到控制台上吧。</p></blockquote> <p>$evalAsync 和 $$postDigest 的异常处理是在 $digest 函数里，在这些场景里，从已列入计划的程序中抛出的异常将被记录成日志，它后面的还是正常运行：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$digest</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ttl <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$beginPhase</span><span class="token punctuation">(</span><span class="token string">&quot;$digest&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> asyncTask <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$$asyncQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$eval</span><span class="token punctuation">(</span>asyncTask<span class="token punctuation">.</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span>console<span class="token punctuation">.</span>error <span class="token operator">||</span> console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    dirty <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$$digestOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ttl<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$clearPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">throw</span> <span class="token string">&quot;10 digest iterations reached&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$clearPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$postDigestQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$$postDigestQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span>console<span class="token punctuation">.</span>error <span class="token operator">||</span> console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>监听器的异常处理放在 $$digestOnce 里。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$$digestOnce</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> dirty<span class="token punctuation">;</span>
  _<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$$watchers<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> newValue <span class="token operator">=</span> watch<span class="token punctuation">.</span><span class="token function">watchFn</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> oldValue <span class="token operator">=</span> watch<span class="token punctuation">.</span>last<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">$$areEqual</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> watch<span class="token punctuation">.</span>valueEq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        watch<span class="token punctuation">.</span><span class="token function">listenerFn</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">;</span>
        dirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      watch<span class="token punctuation">.</span>last <span class="token operator">=</span> watch<span class="token punctuation">.</span>valueEq <span class="token operator">?</span> _<span class="token punctuation">.</span><span class="token function">cloneDeep</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token operator">:</span> newValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span>console<span class="token punctuation">.</span>error <span class="token operator">||</span> console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> dirty<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们的 digest 循环碰到异常的时候健壮多了。</p> <p>http://jsbin.com/IMEhowO/2/embed?js,console</p> <h2 id="销毁一个监听器"><a href="#销毁一个监听器" class="header-anchor">#</a> 销毁一个监听器</h2> <p>当注册一个监听器的时候，一般都需要让它一直存在于整个作用域的生命周期，所以很少会要显式把它移除。也有些场景下，需要保持作用域的存在，但要把某个监听器去掉。</p> <p>Angular 中的 $watch 函数是有返回值的，它是个函数，如果执行，就把刚注册的这个监听器销毁。想在我们这个版本里实现这功能，只要返回一个函数在里面把这个监控器从 $$watchers 数组去除就可以了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Scope</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">watchFn<span class="token punctuation">,</span> listenerFn<span class="token punctuation">,</span> valueEq</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">watchFn</span><span class="token operator">:</span> watchFn<span class="token punctuation">,</span>
    <span class="token literal-property property">listenerFn</span><span class="token operator">:</span> listenerFn<span class="token punctuation">,</span>
    <span class="token literal-property property">valueEq</span><span class="token operator">:</span> <span class="token operator">!</span><span class="token operator">!</span>valueEq<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  self<span class="token punctuation">.</span>$$watchers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> index <span class="token operator">=</span> self<span class="token punctuation">.</span>$$watchers<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      self<span class="token punctuation">.</span>$$watchers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们就可以把 $watch 的这个返回值存起来，以后调用它来移除这个监听器：</p> <p>http://jsbin.com/IMEhowO/4/embed?js,console</p> <h2 id="展望未来"><a href="#展望未来" class="header-anchor">#</a> 展望未来</h2> <p>我们已经走了很长一段路了，已经有了一个完美可以运行的类似 Angular 这样的脏检测作用域系统的实现了，但是 Angular 的作用域上面还做了更多东西。</p> <p>或许最重要的是，在 Angular 里，作用域并不是孤立的对象，作用域可以继承于其他作用域，监听器也不仅仅是监听本作用域上的东西，还可以监听这个作用域的父级作用域。这种方法，概念上很简单，但是对于初学者经常容易造成混淆。所以，本系列的下一篇文章主题就是作用域的继承。</p> <p>后面我们会讨论 Angular 的事件系统，也是实现在 Scope 上的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/AngularJS/DI.html">
        DI
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.12d26605.js" defer></script><script src="/assets/js/53.72aa59c3.js" defer></script><script src="/assets/js/2.e0269be8.js" defer></script><script src="/assets/js/1.c44a8a87.js" defer></script><script src="/assets/js/56.9d7794d3.js" defer></script>
  </body>
</html>
