---
sidebarDepth: 1
---

# 数据结构与算法(二)

[[toc]]

## 二叉树遍历

```javascript
const a = {
  val: 1,
  left: {
    val: 2,
  },
  right: {
    val: 3,
  },
};

function preorder(root) {
  if (!root) {
    return;
  }
  console.log(root.val);
  preorder(root.left);
  preorder(root.right);
}

function inorder(root) {
  if (!root) {
    return;
  }
  preorder(root.left);
  console.log(root.val);
  preorder(root.right);
}

function postorder(root) {
  if (!root) {
    return;
  }
  preorder(root.left);
  preorder(root.right);
  console.log(root.val);
}
```

## 快速排序

```javascript
function quickSort(array) {
  quick(array, 0, array.length - 1);
  return array;
}

function quick(array, left, right) {
  let index;
  if (array.length > 1) {
    index = partition(array, left, right);
    if (left < index - 1) {
      quick(array, left, index - 1);
    }
    if (index < right) {
      quick(array, index, right);
    }
  }
}

function partition(array, left, right) {
  let povit = array[Math.floor((right + left) / 2)];
  var i = left;
  var j = right;
  while (i <= j) {
    while (array[i] < povit) {
      i++;
    }
    while (array[j] > povit) {
      j--;
    }
    if (i <= j) {
      swap(array, i, j);
      i++;
      j--;
    }
  }
  return i;
}

function swap(array, left, right) {
  [array[left], array[right]] = [array[right], array[left]];
}

console.log(quickSort([1, 23, 5, 77, 9, 222, 10, 18, 45, 23, 2, 4, 667, 8, 3]));

/***
 * left rigth 叠加
 * 从顶部到底部，做完一层才分下去
 * povit
 * partition
 * qiuck
 * Math.floor 向下取整
 * Math.ceil 向上取整
 */
```

## 归并排序

```javascript
/* eslint-disable */
function mergeSort(arr) {
  const length = arr.length;
  if (length === 1) return arr;
  let mad = Math.floor(length / 2);
  let left = arr.slice(0, mad);
  let right = arr.slice(mad, length);
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  let result = [];
  let il = 0,
    ir = 0;
  while (il < left.length && ir < right.length) {
    if (left[il] < right[ir]) {
      result.push(left[il]);
      il++;
    } else {
      result.push(right[ir]);
      ir++;
    }
  }
  while (il < left.length) {
    result.push(left[il]);
    il++;
  }
  while (ir < right.length) {
    result.push(right[ir]);
    ir++;
  }
  return result;
}

/**
 * mergeSort
 * merge
 * mad
 * left
 * right
 * while(il<left.length&&rl<right.lengt)
 * 二重递归
 * */

console.log(mergeSort([1, 3, 333, 45, 12, 5, 7, 8, 9]));
```

## 冒泡排序

```javascript
function bubbleSort(arr) {
  const length = arr.length;
  let num = 0;
  while (num < length - 1) {
    for (let i = 0; i < length - num - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        swag(arr, i, i + 1);
      }
    }
    num++;
  }
  return arr;
}

function swag(arr, left, right) {
  [arr[left], arr[right]] = [arr[right], arr[left]];
}

/**
 * swag 的后两个参数是键index
 * num 为0或者为1，用length为2的值
 */

console.log(bubbleSort([1, 3, 88, 5, 6, 33, 56, 2, 11, 4, 3, 45, 3, 1, 0]));
```

## 防抖和节流

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function() {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(fn, delay);
  };
}

function throttle(fn, deley = 100) {
  let timeoutId = null;
  return function() {
    if (timeoutId) {
      return;
    }
    timeoutId = setTimeout(() => {
      fn.apply(this, arguments);
      timeoutId = null;
    }, deley);
  };
}
```

## 防抖和节流 hooks

```javascript
function useDebounce(fn, delay, dep = []) {
  const { current } = useRef({ fn, timer: null });
  useEffect(
    function() {
      current.fn = fn;
    },
    [fn]
  );

  return useCallback(function f(...args) {
    if (current.timer) {
      clearTimeout(current.timer);
    }
    current.timer = setTimeout(() => {
      current.fn.call(this, ...args);
    }, delay);
  }, dep);
}

function useThrottle(fn, delay, dep = []) {
  const { current } = useRef({ fn, timer: null });
  useEffect(
    function() {
      current.fn = fn;
    },
    [fn]
  );

  return useCallback(function f(...args) {
    if (!current.timer) {
      current.timer = setTimeout(() => {
        delete current.timer;
      }, delay);
      current.fn.call(this, ...args);
    }
  }, dep);
}
```

## 让一个函数执行固定次数

```javascript
function a(a) {
  console.log(1111, a);
}

function times(fn, times) {
  let atime = 0;
  return function(...args) {
    if (atime < times) {
      fn.apply(this, args);
      atime++;
    }
  };
}

const tagert = times(a, 3);
tagert(1);
tagert(2);
tagert(3);
tagert(4);
```

## 模板渲染

```javascript
let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
let data = {
  name: '姓名',
  age: 18,
};
render(template, data); // 我是姓名，年龄18，性别undefined
```

```javascript
function render(template, data) {
  const reg = /\{\{(\w+)\}\}/g; // 模板字符串正则
  return template.replace(reg, function($1, $2) {
    return data[$2];
  });
}
```

## 转化为驼峰命名

```javascript
var s1 = 'get-element-by-id';
var f = function(s) {
  return s.replace(/-\w/g, function(x) {
    return x.slice(1).toUpperCase();
  });
};
```

## 查找字符串中出现最多的字符和个数

例: abbcccddddd -> 字符最多的是 d，出现了 5 次

```javascript
let str = 'abcabcabcbbccccc';
let num = 0;
let char = '';

// 使其按照一定的次序排列
str = str
  .split('')
  .sort()
  .join('');
// "aaabbbbbcccccccc"

// 定义正则表达式
let re = /(\w)\1+/g;
str.replace(re, ($0, $1) => {
  if (num < $0.length) {
    num = $0.length;
    char = $1;
  }
});
console.log(`字符最多的是${char}，出现了${num}次`);
```

## 实现千位分隔符

```javascript
var string1 = '12345678',
  string2 = '123456789';
var reg = /(?!^)(?=(\d{3})+$)/g;

var result = string1.replace(reg, ',');
console.log(result); // => "12,345,678"

result = string2.replace(reg, ',');
console.log(result); // => "123,456,789"
```

```javascript
// 小数点前面的数字，每隔三个数加一个 ','
var string = '123456.3435';
var reg = /(\d)(?=(\d{3})+\.)/g;
var result = string.replace(reg, '$1,');
console.log(result); // => "123,456.3435"
```

## 判断是否是电话号码

```javascript
function isPhone(tel) {
  var regx = /^1[34578]\d{9}$/;
  return regx.test(tel);
}
```

## 验证是否是邮箱

```javascript
function isEmail(email) {
  var regx = /^([a-zA-Z0-9_\-])+@([a-zA-Z0-9_\-])+(\.[a-zA-Z0-9_\-])+$/;
  return regx.test(email);
}
```

## 验证是否是身份证

```javascript
function isCardNo(number) {
  var regx = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;
  return regx.test(number);
}
```

## 实现柯里化

```javascript
function createCurry(func, args) {
  var argity = func.length;
  var args = args || [];

  return function() {
    var _args = [].slice.apply(arguments);
    args.push(..._args);

    if (args.length < argity) {
      return createCurry.call(this, func, args);
    }

    return func.apply(this, args);
  };
}
```

## 实现函数能够深度克隆基本类型

```javascript
function deepCopy(obj) {
  if (typeof obj === 'object') {
    var result = obj.constructor === Array ? [] : {};

    for (var i in obj) {
      result[i] = typeof obj[i] === 'object' ? deepCopy(obj[i]) : obj[i];
    }
  } else {
    var result = obj;
  }

  return result;
}
```
