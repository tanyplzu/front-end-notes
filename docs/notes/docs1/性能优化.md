# 前端性能优化

[[toc]]

::: tip 原则:

- 多使用内存、缓存或者其他方法
- 减少 CPU 计算、较少网络

:::

## 加载资源优化

- 静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）
- 静态资源缓存（资源名称加 MD5 戳）
- 使用 CND 让资源加载更快
- 使用 SSR 后端渲染，数据直接突出到 HTML 中

> http2 采用多路复用后，雪碧图现在基本没有用了

## 渲染优化

- CSS 放前面 JS 放后面
- 懒加载（图片懒加载、下拉加载更多）
- 减少 DOM 查询，对 DOM 查询做缓存
- 减少 DOM 操作，多个操作尽量合并在一起执行（`DocumentFragment`）
- 事件节流
- 尽早执行操作（`DOMContentLoaded`）

## 图片优化

### 计算图片大小

对于一张 100 /_ 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1 个字节），所以该图片大小大概为 39KB（10000 /_ 1 /\* 4 / 1024）。

- 减少像素点
- 减少每个像素点能够显示的颜色

### 图片加载优化

- 按钮之类的图标使用 css 实现
- 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
- 小图使用 base64 格式，webpack 可以直接转码。
- 将多个图标文件整合到一张图片中（雪碧图），http2 没有必要使用雪碧图。
- 选择正确的图片格式：对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好。
- 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
- 照片使用 JPEG

## DNS 预解析

```html
<link rel="dns-prefetch" href="//yuchengkai.cn" />
```

## 预加载

预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com" />
```

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

对应的还有 prefetch

```html
<link rel="preload" href="/front-end/assets/js/33.6fd3e2b4.js" as="script" />
<link rel="prefetch" href="/front-end/assets/js/10.d48e413a.js" />
```

## 预渲染

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com" />
```

预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。

### 事件节流

例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。

```js
var textarea = document.getElementById('text');
var timeoutId;
textarea.addEventListener('keyup', function() {
  if (timeoutId) {
    clearTimeout(timeoutId);
  }
  timeoutId = setTimeout(function() {
    // 触发 change 事件
  }, 100);
});
```

## 尽早执行操

```js
window.addEventListener('load', function() {
  // 页面的全部资源加载完才会执行，包括图片、视频等
});
document.addEventListener('DOMContentLoaded', function() {
  // DOM 渲染完即可执行，此时图片、视频还可能没有加载完
});
```

## 首屏和白屏时间如何计算

首屏时间的计算，可以由 Native WebView 提供的类似 onload 的方法实现，在 ios 下对应的是 webViewDidFinishLoad，在 android 下对应的是 onPageFinished 事件。

白屏的定义有多种。可以认为“没有任何内容”是白屏，可以认为“网络或服务异常”是白屏，可以认为“数据加载中”是白屏，可以认为“图片加载不出来”是白屏。场景不同，白屏的计算方式就不相同。

- 方法 1：当页面的元素数小于 x 时，则认为页面白屏。比如“没有任何内容”，可以获取页面的 DOM 节点数，判断 DOM 节点数少于某个阈值 X，则认为白屏。
- 方法 2：当页面出现业务定义的错误码时，则认为是白屏。比如“网络或服务异常”。
- 方法 3：当页面出现业务定义的特征值时，则认为是白屏。比如“数据加载中”

Google 网页性能分析工具： [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)

## 如何系统地优化页面

通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。

加载阶段：总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。


## 加载阶段性能：使用Audits来优化Web性能

## 页面性能工具：如何使用Performance？

## 性能分析工具：如何分析Performance中的Main指标？

