# 事件



## 原生事件

### 事件的关键要素

​			***EventTarget.addEventListener(EventType,Listener(Event))***

###  Event对象

[Event 接口](https://developer.mozilla.org/zh-CN/docs/Web/API/Event#Properties)

​		[demo eventMethods](./demo/eventMethods.html)

### 事件目标

  	EventTarget 是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。Element，document 和 window 是最常见的事件目标，但是其他对象也可以是事件目标，比如XMLHttpRequest，也可以自定义（[观察者模式](https://mp.weixin.qq.com/s/B1Sp2A8MR8vm4g4EO24glw)）

​	[demo 自定义Eventtarget](./demo/eventtarget.html)



### 事件类型 
[EventType](https://developer.mozilla.org/zh-CN/docs/Web/Events)

列举几个有意思的事件

[online，offline](./demo/online.html)

[stroage](./demo/stroageEvent.html)(需要网络访问)

[compositionstart，compositionend](./demo/composition.html)

[progress](./demo/fileUpload/progress.html)



### 事件的绑定

追溯前端的发展史，有以下三种方式给DOM绑定事件

  #### 1、HTML事件处理程

```html
  <button onclick="alert(123)">widthout param</button>
  <button onclick="handleClick1(123)">normal param</button>
  <button onclick="handleClick2(this)">targetDom param</button>
  <button onclick="handleClick3(event)">event param</button>
  <button onclick="handleClick4(123,this,event)">mixing param</button>
  <button onclick="handleClick4(event,this,123)">mixing param</button>
  <script>
      function handleClick() {
        alert('handleClick widthout param')
      }
      function handleClick1(data) {
        alert('handleClick widt data')
        console.log(data)
      }
      function handleClick2(dom) {
        alert('handleClick widt targetTom')
        console.log(event)
      }
      function handleClick3(event) {
        alert('handleClick widt event')
        console.log(event)
      }
      function handleClick4(data,dom,event) {
        alert('handleClick widt mixing param')
        console.log(data,dom,event)
      }
  </script>
```



 #### 2、DOM0级事件处理程序

```html
  <button id="btn">click</button>
  <script>
    const btn = document.getElementById('btn');
    btn.onclick = function handleClick(event) {
      console.log(this,event)
    }
    // 只能绑定一个click函数，重复绑定会覆盖前面的
    btn.onclick = function handleClick(event) {
      console.log(this.id,event)
    }
    // 移除事件处理程序
    btn.onclick = null;
  </script>
```



 #### 3、DOM2级事件处理程序

```html
<button id="btn">click</button>
<script>
// addEventListener,removeEventListener
// 它允许给一个事件注册多个监听器。 特别是在使用AJAX库，JavaScript模块，或其他需要第三方库/插件的代码。
// 它提供了一种更精细的手段控制 listener 的触发阶段。（即可以选择捕获或者冒泡）。
// 它对任何 DOM 元素都是有效的，而不仅仅只对 HTML 元素有效。
    const btn = document.getElementById('btn');
    function handleClick(event) {
        console.log(this.id,event)
    }
    function handleClick1(event) {
        console.log(this,event)
    }
    btn.addEventListener('click',handleClick,false)
    btn.addEventListener('click',handleClick1,true)
    btn.removeEventListener('click',handleClick1,false)
</script>
```
#### addEventListener

​	给事件目标添加监听事件

addEventListener参数

最开始是这样的

```js
addEventListener(type, listener, useCapture)
```

后来，监听器是在捕获阶段执行还是在冒泡阶段执行的 useCapture 参数，变成了可选参数（传 true 的情况太少了）

```js
addEventListener(type, listener[, useCapture ])
```

再后来，addEventListener() 的第三个参数可以是个对象值了，也就是说第三个参数现在可以是两种类型的值了

```js
addEventListener(type, listener, {
    capture: false,
    passive: false,
    once: false
})
```

三个属性都是布尔类型的开关，默认值都为 false。其中 capture 属性等价于以前的 useCapture 参数；once 属性就是表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉；passive 属性设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。



移动端页面监听touch事件

document.addEventListener("touchstart", function(e){
    ... // 浏览器不知道这里会不会有 e.preventDefault()
})

由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。

<video controls src="./video.mp4"/>
chrome, Firefox等浏览器为了保证滚动时的性能，在Window, Document, Document.body上针对touchstart和touchmove事件将passive默认值改为了true， 保证了在页面滚动时不会因为自定义事件中调用了preventDefault而阻塞页面渲染。



目前第二种和第三种方式并存

```js
addEventListener(type, listener[, useCapture ])
addEventListener(type, listener[, options ])
```

removeEventListener 移除事件目标监听事件 listener能够被引用到，第三个参数必须与addEventListener第三个参数一致

target.removeEventListener(type, listener[, options]);
target.removeEventListener(type, listener[, useCapture]);


### 事件的触发

DOM2级事件规定的事件流分为三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段。

<img src="eventflow.svg" width="50%"/>

[demo eventPhase](./demo/eventPhase.html)

### 自定义事件

```js
// 自定义事件
// Event constructor(https://developer.mozilla.org/zh-CN/docs/Web/API/Event/Event)
const event = new Event('build', {
    bubbles: false,
    cancelable: true
});
document.addEventListener('build', (e) => {
	console.log(e.type);
})
document.dispatchEvent(event)
      
```



```js
// 在自定义事件添加数据
const customEvent = new CustomEvent('build', {
    detail: { a: 123, b: '345' },
    bubbles: true,
});
document.addEventListener('build', e => {
	console.log(e.detail);
})
document.body.addEventListener('build', e => {
	console.log(e.detail);
})
document.body.dispatchEvent(customEvent)
```



```js
// 旧方式
var event = document.createEvent('Event');
// event.initEvent(type, bubbles, cancelable);
event.initEvent('build', true, true);
document.addEventListener('build', function (e) {
	console.log(e);
}, false);
document.dispatchEvent(event);

```

## 框架中的事件

React基于事件标准自己实现了一套事件系统，大部分事件代理到document上

Vue基于原生事件，事件挂载在对应的DOM节点上，自己实现了自定义事件。

### React中的事件

**React为什么要自己实现一个事件系统？**

![](C:\Users\zt\Desktop\事件\why-react.jpeg)

**性能**

事件代理

React作为一套View层面的框架，通过渲染得到vDOM，再由diff算法决定DOM树那些结点需要新增、替换或修改，假如直接在DOM结点插入原生事件监听，则会导致频繁的调用addEventListener和removeEventListener，造成性能的浪费。所以React采用了事件代理的方法，对于大部分事件1而言都在document上做监听，然后根据Event中的target来判断事件触发的结点。

池

其次React合成的SyntheticEvent采用了池的思想，从而达到节约内存，避免频繁的创建和销毁事件对象的目的。这也是如果我们需要异步使用一个syntheticEvent，需要执行event.persist()才能防止事件对象被释放的原因。

批量更新

最后在React源码中随处可见batch做批量更新，基本上凡是可以批量处理的事情（最普遍的setState）React都会将中间过程保存起来，留到最后面flush（渲染，并最终提交到DOM树上）掉。

**复用**

而对于复用来说，React看到在不同的浏览器和平台上，用户界面上的事件其实非常相似，例如普通的click，change等等。React希望通过封装一层事件系统，将不同平台的原生事件都封装成SyntheticEvent。

使得不同平台只需要通过加入EventEmitter以及对应的Renderer就能使用相同的一个事件系统，WEB平台上加入ReactBrowserEventEmitter，Native上加入ReactNativeEventEmitter。如下图，对于不同平台，React只需要替换掉左边部分，而右边EventPluginHub部分可以保持复用。
而对于不同的浏览器而言，React帮我们统一了事件，做了浏览器的兼容，例如对于transitionEnd,webkitTransitionEnd,MozTransitionEnd和oTransitionEnd, React都会集合成topAnimationEnd，所以我们只用处理这一个标准的事件即可。

简单而言，就与jQuery帮助我们解决了不同浏览器之间的兼容问一样，React更进一步，还帮我们统一了不同平台的兼容，使我们在开发的时候只需要考虑一个标准类型的事件即可。

React事件系统的设计

![](C:\Users\zt\Desktop\事件\react-event.jpeg)



**React的事件系统是怎么运作起来的？**

事件绑定

![](C:\Users\zt\Desktop\事件\react-event-bind.jpg)

事件触发

<iframe src="https://www.lzane.com/animate/react-event-system/index.html" style="border:0; width:100%; height:500px; overflow:hidden"></iframe>
### Vue中的事件

Vue采用的是原生的事件，Vue中的事件一大亮点是[修饰符](https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6)和自定义事件，关于修饰符的实现原理和前面讲的原生事件的方法属性关联在一起理解起来就容易了

```html
<a v-on:click.stop="doThis"></a>
```

```js
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};
```



通过一个例子来看下Vue对事件绑定

App.vue

```vue
<template>
    <child @select="selectHandler" @click.native.prevent="clickHandler"/>
</template>
<script>
import Child from "./components/Child";
export default {
  components: { Child },
  methods: {
    clickHandler() {console.log('Child click');},
    selectHandler() {console.log('Child selected');}
  }
};
</script>
```

Child.vue

```vue
<template>
  <button @click="clickHandler($event)">click me</button>
</template>
<script>
export default {
  methods: {
    clickHandler(e) {
      console.log("button clicked", e);
      this.$emit("select");
    }
  }
};
</script>
```



源代码-->AST-->Vnode-->Element-->插入根节点



编译
	**parse**
		parse的目标是把template模板字符串转换成AST树，用JavaScript对象的形式来描述整个模板
	**optimize**
		optimize的过程，就是深度遍历这个AST树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成DOM永远不需要改变，这对运行时对模板的更新起到极大的优化作用
	**generate**
		ast->code 
编译后生成的代码就是在运行时执行的代码

```vue
<child @select="selectHandler" @click.native.prevent="clickHandler"/>
```

在parse阶段，处理事件指令，区分是原生事件还是普通事件，在AST节点上添加el.events 和 el.nativeEvents

<details>
<summary>展开查看详细信息</summary>
<pre>
	在parse阶段，会执行processAttrs(el)方法，这个方法负责处理标签的属性，在处理标签属性的过程中，如果某个属性是指令，首先通过parseModifiers解析出指令，然后判断如果是事件指令，就执行addHandler(el, name, value, modifiers, false, warn)方法，区分是原生还是普通事件，按照name对事件进行归类，这一阶段会在AST节点上添加el.events 和 el.nativeEvents
</pre>
</details>

```js
// App
el.events = {
  select: {
    value: 'selectHandler'
  }
}

el.nativeEvents = {
  click: {
    value: 'clickHandler',
    modifiers: {
      prevent: true
    }
  }
}
// Child
el.events = {
  click: {
    value: 'clickHandler($event)'
  }
}
```

在generate阶段，根据AST元素节点上的events和nativeEvents生成相应的代码。

<details>
<summary>展开查看详细</summary>
<pre>
	在generate阶段，会在genData函数中根据AST元素节点上的events和nativeEvents调用genHandlers(events,isNative)函数生成代码，在这个函数里会判断监听事件是函数调用还是函数表达式，接着对修饰符做判断，根据不同的修饰符添加相应的代码串。
</pre>
</details>


```js
// App
{
  on: {"select": selectHandler},
  nativeOn: {"click": function($event) {
      $event.preventDefault();
      return clickHandler($event)
    }
  }
}
// Child
{
  on: {"click": function($event) {
      clickHandler($event)
    }
  }
}
```

**patch**阶段的整个过程就是根据Vnode递归创建了一个完整的DOM树并插入到Body上。

在创建DOM的时候需要设置DOM元素相关的属性、样式、事件等相关属性，这里只关心事件。



在原生DOM事件中真正添加回调和移除回调函数的实现，就是实际上调用原生addEventListener和removeEventListener，并根据参数传递一些配置。

*注意这里的hanlder会用withMacroTask(hanlder)包裹一下，实际上就是强制在DOM事件的回调函数执行期间如果修改了数据，那么这些数据更改推入的队列会被当做macroTask在nextTick后执行。*

自定义事件add和remove的实现，实际上是利用Vue定义的事件中心，实现原理：非常经典的观察者模式的实现，把所有的事件用vm._events存储起来，当执行vm.$on(event,fn)的时候，按事件的名称event把回调函数fn存储起来vm._events[event].push(fn)。当执行vm.$emit(event)的时候，根据事件名event找到所有的回调函数 let cbs=vm._events[event]，然后遍历执行所有的回调函数。当执行vm.$off(event,fn)的时候会移除指定事件名event和指定的fn。

*需要注意的事一点，vm.$emit是给当前的vm上派发的实例，之所以我们常用它做父子组件通讯，是因为它的回调函数的定义是在父组件中，对于我们这个例子而言，当子组件的button被点击了，它通过this.$emit('select')派发事件，那么子组件的实例就监听到了这个select事件，并执行它的回调函数——定义在父组件中的selectHandler方法，这样就相当于完成了一次父子组件的通讯。*


<details>
<summary>展开查看详细</summary>
<pre>
	创建阶段和更新阶段都会执行updateDOMListeners(oldVnode,vnode)，首先获取vnode.data.on，这就是我们之前的生成的data中对应的事件对象。接着去调updateListeners(on,oldOn,add,remove,vnode.context)，updateListeners的逻辑很简单，遍历on去添加事件监听，遍历oldOn去移除事件监听，关于监听和移除事件的方法都是外部传入的，因为它既处理原生DOM事件的添加删除，也处理自定义事件的添加删除。
</pre>
</details>





