---
title: "vue响应式原理"
sidebarDepth: 2

---

## vue响应式原理

响应式原理及实现
实现Dep类

- 创建一个Dep类，包含两个方法：depend和notify
- 创建一个autorun函数，传入一个update函数作为参数
- 在update函数中调用dep.depend()，显式依赖于Dep实例
- 调用dep.notify()触发update函数重新运行

```js
const dep = new Dep()
autorun(() => {
  dep.depend()
  console.log('updated')
})
// 注册订阅者，输出 updated
dep.notify()
// 通知改变，输出 updated
```

首先需要定义autorun函数，接收update函数作为参数。因为调用autorun时要在Dep中注册订阅者，同时调用dep.notify()时要重新执行update函数，所以Dep中必须持有update引用，这里使用变量activeUpdate表示包裹update的函数。

```js
let activeUpdate = null 
function autorun (update) {
  const wrappedUpdate = () => {
    activeUpdate = wrappedUpdate    // 引用赋值给activeUpdate
    update()                        // 调用update，即调用内部的dep.depend
    activeUpdate = null             // 绑定成功之后清除引用
  }
  wrappedUpdate()                   // 调用
}
```

wrappedUpdate本质是一个闭包，update函数内部可以获取到activeUpdate变量，同理dep.depend()内部也可以获取到activeUpdate变量，所以Dep的实现就很简单了。

```js
class Dep {
  // 初始化
  constructor () {          
    this.subscribers = new Set()
  }
  // 订阅update函数列表
  depend () {
    if (activeUpdate) {     
      this.subscribers.add(activeUpdate)
    }
  }
  // 所有update函数重新运行
  notify () {              
    this.subscribers.forEach(sub => sub())
  }
}
```

实现响应式系统

- 结合上述两个实例，convert()重命名为观察者observe()
- observe()转换对象的属性使之响应式，对于每个转换后的属性，它会被分配一个Dep实例，该实例跟踪订阅update函数列表，并在调用setter时触发它们重新运行
- autorun()接收update函数作为参数，并在update函数订阅的属性发生变化时重新运行。

```js
const state = {
  count: 0
}

observe(state)

autorun(() => {
  console.log(state.count)
})
// 输出 count is: 0

state.count++
// 输出 count is: 1
```

结合实例1和实例2之后就可以实现上述要求，observe中修改obj属性的同时分配Dep的实例，并在get中注册订阅者，在set中通知改变。autorun函数保存不变。 实现如下：

```js
class Dep {
  // 初始化
  constructor () {          
    this.subscribers = new Set()
  }
  // 订阅update函数列表
  depend () {
    if (activeUpdate) {     
      this.subscribers.add(activeUpdate)
    }
  }
  // 所有update函数重新运行
  notify () {
    this.subscribers.forEach(sub => sub())
  }
}
function observe (obj) {
  // 迭代对象的所有属性
  // 并使用Object.defineProperty()转换成getter/setters
  Object.keys(obj).forEach(key => {
    let internalValue = obj[key]
    // 每个属性分配一个Dep实例
    const dep = new Dep()

    Object.defineProperty(obj, key, {
    
      // getter负责注册订阅者
      get () {
        dep.depend()
        return internalValue
      },
      // setter负责通知改变
      set (newVal) {
        const changed = internalValue !== newVal
        internalValue = newVal
        
        // 触发后重新计算
        if (changed) {
          dep.notify()
        }
      }
    })
  })
  return obj
}
let activeUpdate = null
function autorun (update) {
  // 包裹update函数到"wrappedUpdate"函数中，
  // "wrappedUpdate"函数执行时注册和注销自身
  const wrappedUpdate = () => {
    activeUpdate = wrappedUpdate
    update()
    activeUpdate = null
  }
  wrappedUpdate()
}
```

